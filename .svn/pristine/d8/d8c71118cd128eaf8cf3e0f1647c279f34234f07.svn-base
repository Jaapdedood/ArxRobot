<?xml version="1.0" encoding="utf-8"?>
<!-- ArxRover Main.mxml -->
<s:Application
	xmlns:fx="http://ns.adobe.com/mxml/2009" 
	xmlns:s="library://ns.adobe.com/flex/spark"
	xmlns:mx="library://ns.adobe.com/flex/mx"
	xmlns:comp="components.*"
	xmlns:vw="views.*"
	skinClass="skins.AppGradientSkin"
	backgroundColor="0x222222"
	applicationComplete="_ApplicationCompleted()"
	initialize="_Initialized()"
	>
	<!--
	-->
	<fx:Style source="css/MainStyles.css" />
	<fx:Metadata>
		[ResourceBundle("default")]
	</fx:Metadata>
	<fx:Script>
		<![CDATA[
			import utils.BatteryUtil;
			import com.distriqt.extension.battery.events.BatteryEvent;
			import events.RoverEvent;
			import utils.CompassUtil;
			import com.distriqt.extension.compass.events.CompassEvent;
			import flash.sensors.Accelerometer;
			import com.smartfoxserver.v2.SmartFox;
			import com.smartfoxserver.v2.core.SFSEvent;
			import com.smartfoxserver.v2.entities.SFSRoom;
			import com.smartfoxserver.v2.entities.User;
			import com.smartfoxserver.v2.entities.data.ISFSObject;
			import com.smartfoxserver.v2.entities.data.SFSObject;
			import com.smartfoxserver.v2.entities.variables.SFSUserVariable;
			import com.smartfoxserver.v2.redbox.events.RedBoxConnectionEvent;
			import com.smartfoxserver.v2.requests.JoinRoomRequest;
			import com.smartfoxserver.v2.requests.LoginRequest;
			import com.smartfoxserver.v2.requests.LogoutRequest;
			import com.smartfoxserver.v2.requests.PrivateMessageRequest;
			import com.smartfoxserver.v2.requests.SetUserVariablesRequest;
			
			import flash.net.registerClassAlias;
			import flash.sensors.Geolocation;
			
			import mx.collections.ArrayList;
			
			import controllers.DialogManager;
			
			import events.DebugEvent;
			import events.DialogEvent;
			import events.SocketBytesEvent;
			import events.UtilityEvent;
			
			import skins.ToggleSwitchCustomSkin;
			
			import utils.AVCastManagerAosa;
			import utils.NonUIComponentBase;
			import utils.ServerSocketArduino;
			
			import vo.AccData;
			import vo.CameraConfig;
			import vo.CameraMove;
			import vo.DialogData;
			import vo.DialogOption;
			import vo.EmergencyCodes;
			import vo.Gps;
			import vo.MotorLimits;
			import vo.MoveProps;
			import vo.Ping;
			import vo.RoverData;
			import vo.UserState;
			
			// factors for rolling average
			private const ACC_AVG_FACTOR_CURRENT:Number = 0.25;
			private const ACC_AVG_FACTOR_PREVIOUS:Number = 0.75;
			private const RADIANS_TO_DEGREES:Number = 180.0 / Math.PI;
			
			private var _aCameras:Array;
			
			private var _acc:Accelerometer;
			private var _accData:AccData;
			
			[Bindable]
			private var _alArduinoTypes:ArrayList;
			
			[Bindable]
			private var _alCameras:ArrayList;
			
			private var _aRovers:Array; // array of SFS Room objects
			
			[Bindable]
			private var _alRovers:ArrayList;
			
			private var _avCastMgr:AVCastManagerAosa;
			
			private var _bArduinoTypeAdb:Boolean = true;
			
			[Bindable]
			private var _bCamPans:Boolean;
			
			[Bindable]
			private var _bCamTilts:Boolean;
			
			[Bindable]
			private var _bDebug:Boolean = true;
			
			[Bindable]
			private var _bLiveCastMonFull:Boolean = true;
			
			[Bindable]
			private var _bLiveCastMonitor:Boolean = false;
			
			private var _bMoving:Boolean;
			public function get isMoving():Boolean
			{
				return _bMoving;
			}
			public function set isMoving(value:Boolean):void
			{
				_bMoving = value;
				if ( _userState.cameraAdjustForMotion )
				{
					if ( _bMoving )
					{
						_cameraConfigActive = _userState.cameraConfigMotion;
					}
					else
					{
						_cameraConfigActive = _userState.cameraConfigDefault;
					}
					callLater ( _LiveCastConfigUpdate );
				}
			}
			
			[Bindable]
			private var _bOsIsAndroid:Boolean = true;
			
			[Bindable]
			private var _camera:Camera;
			
			private var _cameraConfigActive:CameraConfig;
			
			private var _dialogMgr:DialogManager;
			private var _dirStorage:File;
			
			private var _fArduinoSend:Function = _NoOp;
			
			private var _geo:Geolocation;
			private var _gps:Gps;
			
			private var _iAppHt:int;
			private var _iAppWd:int;
			
			[Bindable]
			private var _iArduinoTypeIdx:int = 1;
			
			[Bindable]
			private var _iChatHt:int = 200;
			[Bindable]
			private var _iChatWd:int = 160;
			
			private var _iDcMin:int = 100;
			private var _iDcTop:int = 212;
			private var _nDcScale:Number = 112/255;
			
			private var _iHeading:int = 0;
			
			private var _iPilotUserId:int = 0;
			
			private var _iPitch:int = 0;
			private var _iRoll:int = 0;
			
			private var _iSfsLagRT:int = 200; // will update to latest average from SmartFox's lag monitoring
			
			private var _iVideoActualHt:int;
			private var _iVideoActualWd:int;
			
			[Bindable]
			private var _iVideoMonLeft:int = 0;
			[Bindable]
			private var _iVideoMonTop:int = 0;
			[Bindable]
			private var _iVideoMonWd:int = 800;
			[Bindable]
			private var _iVideoMonHt:int = 480;
			
			private var _iVideoMonFullHt:int;
			private var _iVideoMonFullWd:int;
			private var _iVideoMonPortWd:int;
			[Bindable]
			private var _iVideoMonPortHt:int;
			
			private var _moveProps:MoveProps; // stores most recent request
			
			private var _nBatteryPct:Number = 100;
			private var _nDeviceAspectRatio:Number;
			private var _nVideoPortFract:Number = 0.4; // adjust this as our GUI dictates
			
			private var _nsLiveCast:NetStream;
			
			[Bindable]
			private var _oRover:SFSRoom;
			
			private var _pvArduino:PrimaveraInterface;
			
			private var _reLine0:RegExp = /^.*[\n\r]/;
			private var _reNewLines:RegExp = /[\n\r]/g;
			
			private var _roverData:RoverData;
			
			[Bindable]
			private var _sConnectPrompt:String;
			
			[Bindable]
			private var _sf:SmartFox;
			
			private var _sRoverPass:String;
			
			private var _ssArduino:ServerSocketArduino;
			
			private var _tmrConnect:Timer; // connection timeout
			private var _tmrDog:Timer; // watch dog timer
			private var _tmrFps:Timer; // camera FPS polling
			
			private var _userState:UserState;
			
			private var _video:Video;
			
			//--------------------------Tuan----------------------------------------------------
			//Code for Arudino ANE
		//	private var _arduino:AndroidMegaInterface;
			/*
			private var lastTemperature:Number=0;
			private var lastUsRangeLeft:Number=0;
			private var lastUsRangeRight:Number=0;
			private var lastCleanBat:Number=0;
			private var lastDirtyBat:Number=0;
			*/
			
			// app startup event order (of those we typically listen for):
			//   initialize
			//   creationComplete
			//   applicationComplete
			private function _ApplicationCompleted ( ) : void
			{
				NonUIComponentBase.eventRelay = this;
				
				_iAppHt = height;
				_iAppWd = width;
				_bOsIsAndroid = ( Capabilities.version.substr ( 0, 3 ) == "AND" );
				
				_alArduinoTypes = new ArrayList ( [ 'Arduino as Host', 'Microbridge' ] );
				
				_iChatHt = Math.max ( 200, _iAppHt * 0.6 );
				
				_nDeviceAspectRatio = 1.0 * _iAppHt / _iAppWd;
				
				// get DialogManager (singleton) instance
				_dialogMgr = DialogManager.getInstance ( );
				
				// events from objects in display list, using capture phase
				//    debug
				addEventListener ( DebugEvent.DEBUG_OUT, _DebugOutReceived, true );
				//    route dialog events to DialogManager
				addEventListener ( DialogEvent.ALERT, _dialogMgr.mAlertEventHandler, true );
				addEventListener ( DialogEvent.DIALOG, _dialogMgr.mDialogEventHandler, true );
				
				// events from subclasses of NonUIComponentBase, using this as eventRelay
				//    debug
				addEventListener ( DebugEvent.DEBUG_OUT, _DebugOutReceived );
				//    route dialog events to DialogManager
				addEventListener ( DialogEvent.ALERT, _dialogMgr.mAlertEventHandler );
				addEventListener ( DialogEvent.DIALOG, _dialogMgr.mDialogEventHandler );
				
				// Alert usage example:
				// dispatchEvent(new DialogEvent(DialogEvent.ALERT,'alert_test_message','alert_test_title',['Foo','Bar','Fubar']))
				
				_moveProps = MoveProps.newFromParameters ( );
				
				_tmrConnect = new Timer ( 10000, 1 );
				_tmrConnect.addEventListener ( TimerEvent.TIMER, _SfsConnectTimeout );
				
				_tmrFps = new Timer ( 2000, 0 );
				_tmrFps.addEventListener ( TimerEvent.TIMER, _CameraFpsPoll );
				
				// default watch dog to 2.1 secs, then adjust when get current value from ping
				_tmrDog = new Timer ( 2100, 1 );
				_tmrDog.addEventListener ( TimerEvent.TIMER, _WatchDogBark );
				
				// instantiate roverData value object
				_roverData = new RoverData();
				//---------------------------------Tuan-------------------------------------
				// create instance Arduino
				//	_arduino = AndroidMegaInterface.instance;
				// Listener event for data send from the rover
				//	_arduino.addEventListener(RoverEvent.ROVER_DATA, onData);
				
				//--------------------------------------------------------------------------
				//	_arduino.addEventListener ( DebugEvent.DEBUG_OUT, _DebugOutReceived );
				
				_LocalFilesInitialize ( );
				
				// var aCamNames:Array = Camera.names;
				_aCameras = [];
				var iLim:int = Camera.names.length;
				var iCamIdx:int = 0;
				var i_cam:Camera;
				for ( var i:int = 0; i < iLim; i++ )
				{
					i_cam = Camera.getCamera ( String ( i ) );
					if ( i_cam.position == CameraPosition.BACK )
						iCamIdx = i;
					_aCameras.push ( i_cam );
				}
				_alCameras = new ArrayList ( _aCameras );
				if ( _userState.cameraIndex > -1 && _userState.cameraIndex < iLim )
				{
					iCamIdx = _userState.cameraIndex;
				}
				else
				{
					_userState.cameraIndex = iCamIdx;
				}
				_camera = _aCameras [ iCamIdx ];
				
				// instantiate SmartFox client class
				_sf = new SmartFox ( true );
				// SmartFox event listeners
				_sf.addEventListener ( SFSEvent.CONFIG_LOAD_FAILURE, _SfsConfigLoadFailure );
				_sf.addEventListener ( SFSEvent.CONFIG_LOAD_SUCCESS, _SfsConfigLoadSuccess );
				_sf.addEventListener ( SFSEvent.CONNECTION, _SfsConnection );
				_sf.addEventListener ( SFSEvent.CONNECTION_LOST, _SfsConnectionLost );
				_sf.addEventListener ( SFSEvent.PING_PONG, _SfsLagMonitorUpdate );
				_sf.addEventListener ( SFSEvent.ROOM_JOIN_ERROR, _SfsJoinFailure );
				_sf.addEventListener ( SFSEvent.ROOM_JOIN, _SfsJoinSuccess );
				_sf.addEventListener ( SFSEvent.LOGIN_ERROR, _SfsLoginFailure );
				_sf.addEventListener ( SFSEvent.LOGIN, _SfsLoginSuccess );
				_sf.addEventListener ( SFSEvent.LOGOUT, _SfsLogoutDone );
				_sf.addEventListener ( SFSEvent.PRIVATE_MESSAGE, _SfsPrivateMessageReceived );
				// _sfs.addEventListener ( SFSEvent.ROOM_VARIABLES_UPDATE, _SfsRoomVarsUpdate );
				// _sfs.addEventListener ( SFSEvent.USER_VARIABLES_UPDATE, _SfsUserVarsUpdate );
				
				//-------------------------------Tuan---------------------------------
				// Funcionality of this listener moved to _SfsPrivateMessageReceived
				// on 7/5/2013 by gch.
				// Tuan: listener event for private message to control the Rover
				// _sf.addEventListener ( SFSEvent.PRIVATE_MESSAGE, _onCommand);
				//-------------------------------------------------------------------
				
				// _DebugOut ( 'SmartFox API: ' + _sfs.version );
				_sf.loadConfig ( 'config/sfs-config.xml', false );
			}
			
			private function _ApplicationConfigure ( ) : void
			{
				var bPersist:Boolean = false;
				// Microbridge vs Android as host
				_bArduinoTypeAdb = ( _iArduinoTypeIdx > 0 );
				if ( _bArduinoTypeAdb != _userState.arduinoTypeAdb )
				{
					_userState.arduinoTypeAdb = _bArduinoTypeAdb;
					bPersist = true;
				}
				if ( _camera.index != _userState.cameraIndex )
				{
					// user changed camera from default
					_userState.cameraIndex = _camera.index;
					bPersist = true;
				}
				if ( _bCamPans != _userState.cameraCanPan )
				{
					_userState.cameraCanPan = _bCamPans;
					bPersist = true;
				}
				if ( _bCamTilts != _userState.cameraCanTilt )
				{
					_userState.cameraCanTilt = _bCamTilts;
					bPersist = true;
				}
				// anything changed?
				if ( bPersist )
				{
					callLater ( _UserStatePersist );
				}
				
				if ( _bArduinoTypeAdb )
				{
					// instantiate server socket to communicate with Arduino
					_ssArduino = new ServerSocketArduino ( );
					_ssArduino.addEventListener ( SocketBytesEvent.SOCKET_BYTES, _TelemetryInFromServerSocket );
					// have server socket listen on the port to which we want Arduino to connect
					_ssArduino.listen ( 4567 );
					// send via ADB
					_fArduinoSend = _ArduinoSendAdb;
				}
				else
				{
					// instantiate Primavera ANE to communicate with Arduino
					_pvArduino = PrimaveraInterface.instance;
					_pvArduino.addEventListener ( RoverEvent.ROVER_DATA, _TelemetryInFromPrimavera );
					_pvArduino.addEventListener ( DebugEvent.DEBUG_OUT, _DebugOutReceived );
					// send via ANE
					_fArduinoSend = _ArduinoSendAne;
				}
				
				// instantiate Accelerometer value object
				_accData = new AccData ( );
				if ( Accelerometer.isSupported )
				{
					_acc = new Accelerometer ( );
					_acc.setRequestedUpdateInterval ( 200 );
					_acc.addEventListener ( AccelerometerEvent.UPDATE, _AccelerometerUpdated );
				}
				else
				{
					_DebugOut ( 'Accelerometer not supported' );
				}
				
				// instantiate Gps value object
				_gps = new Gps ( );
				if ( Geolocation.isSupported )
				{
					try
					{
						_geo = new Geolocation();
						// register to receive location updates
						_geo.addEventListener ( GeolocationEvent.UPDATE, _GeolocationUpdated );
						_geo.setRequestedUpdateInterval ( 1000 );
					}
					catch(err:Error)
					{
						_DebugOut ( 'Problem initializing geolocation service: ' + err.message );
					}
					// Flex is not able to detect if the location is coming from
					// the wifi, network, or the GPS. We would need an ANE to
					// detect if it is specifically the GPS that is turned on.
				}
				else
				{
					_DebugOut ( 'Location service not supported' );
				}
				
				// Compass
				var compass:CompassUtil = CompassUtil.instance;
				if ( compass.isSupported )
				{
					compass.service.addEventListener ( CompassEvent.HEADING_UPDATED, _CompassHeadingUpdated );
				}
				
				// Battery
				var battery:BatteryUtil = BatteryUtil.instance;
				if ( battery.isSupported )
				{
					battery.service.addEventListener ( BatteryEvent.BATTERY_INFO, _BatteryUpdated );
				}
				
				currentState = 'login_prompt';
			}
			
			private function _AccelerometerUpdated ( event:AccelerometerEvent ) : void
			{
				// we multiply roll by -1 because the degrees are opposite on the screen
				// and on the accelerometer
				var aVarsToSend:Array = [];
				
				// pitch
				_accData.accelerationZ = ( ACC_AVG_FACTOR_CURRENT * event.accelerationZ ) + ( ACC_AVG_FACTOR_PREVIOUS * _accData.accelerationZ );
				var nPt:Number = RADIANS_TO_DEGREES * Math.asin ( _accData.accelerationZ );
				var iPt:int = int ( Math.round ( nPt ) );
				if ( iPt != _iPitch )
				{
					_iPitch = iPt;
					aVarsToSend.push ( new SFSUserVariable ( 'pt', nPt ) );
				}
				
				// roll
				_accData.accelerationX = ( ACC_AVG_FACTOR_CURRENT * event.accelerationX ) + ( ACC_AVG_FACTOR_PREVIOUS * _accData.accelerationX );
				var nRo:Number = -RADIANS_TO_DEGREES * Math.asin ( _accData.accelerationX );
				var iRo:int = int ( Math.round ( nRo ) );
				if ( iRo != _iRoll )
				{
					_iRoll = iRo;
					aVarsToSend.push ( new SFSUserVariable ( 'ro', nRo ) );
				}
				
				// _DebugOut ( 'iPt: ' + iPt + '   iRo: ' + iRo );
				// if we have anything in array, send it
				if ( aVarsToSend.length > 0 )
					_sf.send ( new SetUserVariablesRequest ( aVarsToSend ) );
			}
			
			private function _ArduinoSendAdb ( ba:ByteArray ) : void
			{
				// uses ServerSocket to communicate with Arduino via ADB Microbridge
				_ssArduino.send ( ba );
			}
			
			private function _ArduinoSendAne ( ba:ByteArray ) : void
			{
				// uses ANE to communicate with Arduino via Android as Host
				_pvArduino.sendCommand ( ba );
			}
			
			private function _AvCastMgrDismiss ( ) : void
			{
				if ( _avCastMgr != null )
				{
					_avCastMgr.removeEventListener ( RedBoxConnectionEvent.AV_CONNECTION_INITIALIZED, _AvConnectionInited );
					_avCastMgr.removeEventListener ( RedBoxConnectionEvent.AV_CONNECTION_ERROR, _AvConnectionError );
					_avCastMgr.destroy ( );
					_avCastMgr = null;
				}
			}
			
			private function _AvCastMgrInit ( ) : void
			{
				currentState = 'livecast_wait';
				
				// instantiate AVCastManager
				_avCastMgr = new AVCastManagerAosa ( _sf, _sf.currentIp, false, true );
				
				_avCastMgr.addEventListener ( RedBoxConnectionEvent.AV_CONNECTION_INITIALIZED, _AvConnectionInited );
				_avCastMgr.addEventListener ( RedBoxConnectionEvent.AV_CONNECTION_ERROR, _AvConnectionError );
			}
			
			private function _AvConnectionError ( event:RedBoxConnectionEvent ) : void
			{
				_DebugOut ( 'AV Connection Error: ' + event.params.errorCode );
			}
			
			private function _AvConnectionInited ( event:RedBoxConnectionEvent ) : void
			{
				_LiveCastPublish ( );
			}
			
			private function _BatteryUpdated ( event:BatteryEvent ) : void
			{
				_nBatteryPct = 100 * event.batteryLevel;
				_sf.send ( new SetUserVariablesRequest ( [ new SFSUserVariable ( 'pbt', _nBatteryPct ) ] ) );
			}
			
			private function _InitialVariablesReport ( ) : void
			{
				_SendUserVars ( [
					new SFSUserVariable ( 'ccp', _bCamPans ),
					new SFSUserVariable ( 'cct', _bCamTilts ),
					new SFSUserVariable ( 'ccfga', _userState.cameraAdjustForMotion ),
					new SFSUserVariable ( 'hd', Number ( _iHeading ) ),
					new SFSUserVariable ( 'ro', Number ( _iRoll ) ),
					new SFSUserVariable ( 'pt', Number ( _iPitch ) ),
					new SFSUserVariable ( 'pbt', _nBatteryPct )
				] );
			}
			
			private function _CameraConfigAdjustReport ( ) : void
			{
				_SendUserVars ( [ new SFSUserVariable ( 'ccfga', _userState.cameraAdjustForMotion ) ] );
			}
			
			private function _CameraConfigAdjustRequest ( sfso:ISFSObject ) : void
			{
				// if true, only apply if actually have cameraConfigMotion
				var bVal:Boolean = sfso.getBool ( 'b' );
				if ( bVal )
				{
					if ( !_userState.cameraConfigMotion )
					{
						bVal = false;
					}
				}
				if ( bVal == _userState.cameraAdjustForMotion )
					return;  // no change
				
				_userState.cameraAdjustForMotion = bVal;
				callLater ( _UserStatePersist );
				callLater ( _CameraConfigAdjustReport );
				// if we were moving, the change to cameraAdjustForMotion puts us in non-compliance, so switch config
				if ( _bMoving )
				{
					if ( bVal )
					{
						_cameraConfigActive = _userState.cameraConfigMotion;
					}
					else
					{
						_cameraConfigActive = _userState.cameraConfigDefault;
					}
					callLater ( _LiveCastConfigUpdate );
				}
			}
			
			private function _CameraConfigDefaultRequest ( sfso:ISFSObject ) : void
			{
				_userState.cameraConfigDefault = CameraConfig.newFromSFSObject ( sfso );
				callLater ( _UserStatePersist );
				if ( !isMoving || !_userState.cameraAdjustForMotion )
				{
					_cameraConfigActive = _userState.cameraConfigDefault;
					callLater ( _LiveCastConfigUpdate );
				}
			}
			
			private function _CameraConfigMotionRequest ( sfso:ISFSObject ) : void
			{
				_userState.cameraConfigMotion = CameraConfig.newFromSFSObject ( sfso );
				callLater ( _UserStatePersist );
				if ( isMoving && _userState.cameraAdjustForMotion )
				{
					_cameraConfigActive = _userState.cameraConfigMotion;
					callLater ( _LiveCastConfigUpdate );
				}
			}
			
			private function _CameraConfigReport ( ) : void
			{
				_SendUserVars ( [
					new SFSUserVariable (
						'ccfg',
						new CameraConfig (
							_iVideoActualWd,
							_iVideoActualHt,
							Math.min ( _cameraConfigActive.fps, _camera.currentFPS ),
							_cameraConfigActive.favorArea,
							_camera.bandwidth,
							_camera.quality,
							_camera.keyFrameInterval
						).toSFSObject()
					)
				] );
			}
			
			private function _CameraConfigRequest ( sfso:ISFSObject ) : void
			{
				_cameraConfigActive = CameraConfig.newFromSFSObject ( sfso );
				
				callLater ( _LiveCastPublish );
			}
			
			private function _CameraFpsPoll ( event:TimerEvent ) : void
			{
				_SendUserVars ( [ new SFSUserVariable ( 'cfps', _camera.currentFPS ) ] );
			}
			
			private function _CameraFpsPollRequest ( sfso:ISFSObject ) : void
			{
				var iMsec:int = sfso.getShort ( 'm' ) || 0;
				if ( iMsec < 1 )
				{
					// turn polling off
					_tmrFps.stop();
				}
				else
				{
					if ( iMsec < 500 )
					{
						// don't poll more often than once every half second
						iMsec = 500;
					}
					_tmrFps.delay = iMsec;
					if ( !_tmrFps.running )
					{
						_tmrFps.start();
					}
				}
			}
			
			private function _CameraHomeRequest ( ) : void
			{
				// ##### TESTING #####
				_DebugOut ( 'Arduino command: 4' );
				// ###################
				
				// _arduino.sendComand ( '4' );
				var ba:ByteArray = new ByteArray ( );
				ba.writeByte ( 4 );
				_fArduinoSend ( ba );
			}
			
			private function _CameraMoveRequest ( sfso:ISFSObject ) : void
			{
				var cm:CameraMove = CameraMove.newFromSFSObject ( sfso );
				// ##### TESTING #####
				_DebugOut ( 'Arduino command: ' + cm.commandString );
				// ###################
				// _arduino.sendComand ( sCmd );
				_fArduinoSend ( cm.commandBytes );
			}
			
			private function _CompassHeadingUpdated ( event:CompassEvent ) : void
			{
				// _DebugOut ( event.type + ':  ' + event.magneticHeading + ' (mag)  ' + event.trueHeading + ' (true)  [' + event.headingAccuracy + ' acc]' );
				var nVal:Number = event.trueHeading;
				while ( nVal > 180 )
				{
					nVal -= 360;
				}
				var iVal:int = int ( Math.round ( nVal ) );
				if ( iVal != _iHeading )
				{
					_iHeading = iVal;
					_sf.send ( new SetUserVariablesRequest ( [ new SFSUserVariable ( 'hd', nVal ) ] ) );
				}
			}
			
			private function _DebugOut ( msg:String, sfx:String = '\n' ) : void
			{
				if ( _bDebug )
				{
					var s:String = taDebug.text;
					var iOver:int = s.match ( _reNewLines ).length - 39;
					if ( iOver > 0 )
					{
						for ( var i:int=0; i<iOver; i++ )
						{
							s = s.replace ( _reLine0, '' );
						}
						taDebug.text = s;
					}
					taDebug.appendText ( '-- ' + msg + sfx );
				}
			}
			
			private function _DebugOutReceived ( event:DebugEvent ) : void
			{
				_DebugOut ( event.message );
			}
			
			private function _EmergencyStopReport ( code:uint ) : void
			{
				if ( _HaveValidPilotId ( ) )
				{
					var sfso:ISFSObject = new SFSObject ( );
					sfso.putByte ( 'c', EmergencyCodes.ValidateCode ( code ) );
					_sf.send ( new PrivateMessageRequest ( 'ems', _iPilotUserId, sfso ) );
				}
			}
			
			private function _Exit ( ) : void
			{
				dispatchEvent (
					new DialogEvent (
						DialogEvent.DIALOG,
						'exit_confirm_msg',
						'exit_confirm_title',
						null,
						null,
						new DialogData (
							'exit',
							new <DialogOption> [
								new DialogOption ( 'y', 'yes_label' ),
								new DialogOption ( 'n', 'no_label' )
							],
							-1,
							_ExitResponse
						)
					)
				);
			}
			
			private function _ExitResponse ( commit:Boolean, data:DialogData ) : void
			{
				if ( data.responseIndex == 0 )
				{
					// this does not work on iOS
					NativeApplication.nativeApplication.exit();
				}
			}
			
			private function _GeolocationUpdated ( event:GeolocationEvent ) : void
			{
				var bSend:Boolean = false;
				if ( event.latitude != _gps.lat )
				{
					bSend = true;
					_gps.lat = event.latitude
				}
				if ( event.longitude != _gps.lng )
				{
					bSend = true;
					_gps.lng = event.longitude;
				}
				if ( event.horizontalAccuracy != _gps.accuracy )
				{
					bSend = true;
					_gps.accuracy = event.horizontalAccuracy;
				}
				if ( event.speed != _gps.speed )
				{
					bSend = true;
					_gps.speed = event.speed;
				}
				if ( bSend )
					_sf.send ( new SetUserVariablesRequest ( [ new SFSUserVariable ( 'gps', _gps.toSFSObject() ) ] ) );
			}
			
			private function _HaveValidPilotId ( ) : Boolean
			{
				
				if ( _iPilotUserId < 1 )
					return false;
				
				if ( _sf.userManager.getUserById ( _iPilotUserId ) != null )
					return true;
				
				_iPilotUserId = 0;
				return false;
			}
			
			private function _Initialized ( ) : void
			{
			}
			
			private function _LiveCastCameraAttach ( ) : void
			{
				if ( _bLiveCastMonitor )
				{
					_video.attachCamera ( _camera );
					
				}
				else
				{
					_video.attachCamera ( null );
					_video.clear ( );
				}
			}
			
			private function _LiveCastCheckSize ( ) : void
			{
				var wd:Number = _camera.width || 0;
				if ( wd < 1 )
				{
					callLater ( _LiveCastCheckSize );
				}
				else
				{
					_iVideoActualWd = wd;
					_iVideoActualHt = _camera.height;
					
					var nAspRatio:Number = 1.0 * _iVideoActualHt / _iVideoActualWd;
					var nScale:Number;
					if ( nAspRatio > _nDeviceAspectRatio )
					{
						// height is limiting
						nScale = 1.0 * _iAppHt / _iVideoActualHt;
					}
					else
					{
						nScale = 1.0 * _iAppWd / _iVideoActualWd;
					}
					_iVideoMonFullWd = Math.round ( nScale * _iVideoActualWd );
					_iVideoMonFullHt = Math.round ( nScale * _iVideoActualHt );
					
					_iVideoMonPortWd = Math.round ( _nVideoPortFract * _iVideoMonFullWd );
					_iVideoMonPortHt = Math.round ( _nVideoPortFract * _iVideoMonFullHt );
					
					_iChatWd = Math.min ( 240, Math.max ( 160, _iAppWd - 16 - _iVideoMonPortWd ) );
					
					_LiveCastMonitorSizeSet ( );
					if ( currentState == 'livecast_wait' )
						currentState = 'pilot';
					
					callLater ( _CameraConfigReport );
				}
			}
			
			private function _LiveCastClear ( ) : void
			{
				_LiveCastMonitorClear ( );
				if ( _nsLiveCast != null )
				{
					_avCastMgr.unpublishLiveCast ( );
					_nsLiveCast.dispose ( );
					_nsLiveCast = null;
				}
			}
			
			private function _LiveCastConfigUpdate ( ) : void
			{
				if ( _nsLiveCast == null )
				{
					_LiveCastPublish ( );
				}
				else
				{
					try
					{
						// ask the camera for what we want; we'll find out later what it really gives us
						_camera.setMode (
							_cameraConfigActive.width,
							_cameraConfigActive.height,
							_cameraConfigActive.fps,
							_cameraConfigActive.favorArea
						);
						_camera.setQuality ( _cameraConfigActive.bandWidth, _cameraConfigActive.quality );
						_camera.setKeyFrameInterval ( _cameraConfigActive.keyFrameInterval );
						
						callLater ( _LiveCastCheckSize );
					}
					catch ( e:Error )
					{
						_DebugOut ( 'Live cast config update attempt error: ' + e.message );
					}
				}
			}
			
			private function _LiveCastMonitorClear ( ) : void
			{
				if ( _video )
				{
					_video.attachCamera ( null );
					_video.clear ( );
					uicVideo.removeChild ( _video );
					_video = null;
				}
			}
			
			private function _LiveCastMonitorFullToggle ( ) : void
			{
				_bLiveCastMonFull = !_bLiveCastMonFull;
				_LiveCastMonitorSizeSet ( );
			}
			
			private function _LiveCastMonitorSizeSet ( ) : void
			{
				if ( _bLiveCastMonFull )
				{
					_iVideoMonWd = _iVideoMonFullWd;
					_iVideoMonHt = _iVideoMonFullHt;
					_iVideoMonTop = 0;
					_iVideoMonLeft = ( _iAppWd - _iVideoMonFullWd ) / 2;
				}
				else
				{
					_iVideoMonWd = _iVideoMonPortWd;
					_iVideoMonHt = _iVideoMonPortHt;
					_iVideoMonTop = 8; // whatever gui dictates
					_iVideoMonLeft = 8;
				}
				_LiveCastMonitorUpdate ( );
			}
			
			private function _LiveCastMonitorToggle ( ) : void
			{
				_bLiveCastMonitor = !_bLiveCastMonitor;
				_LiveCastMonitorUpdate ( );
			}
			
			private function _LiveCastMonitorUpdate ( ) : void
			{
				_LiveCastMonitorClear ( );
				if ( _bLiveCastMonitor )
				{
					_video = new Video ( _iVideoActualWd, _iVideoActualHt );
					_video.width = _iVideoMonWd;
					_video.height = _iVideoMonHt;
					uicVideo.addChild ( _video );
					_video.attachCamera ( _camera );
				}
			}
			
			private function _LiveCastPublish ( ) : void
			{
				_LiveCastClear ( );
				// Publish my live cast
				try
				{
					// ask the camera for what we want; we'll find out later what it really gives us
					_camera.setMode (
						_cameraConfigActive.width,
						_cameraConfigActive.height,
						_cameraConfigActive.fps,
						_cameraConfigActive.favorArea
					);
					_camera.setQuality ( _cameraConfigActive.bandWidth, _cameraConfigActive.quality );
					_camera.setKeyFrameInterval ( _cameraConfigActive.keyFrameInterval );
					
					_nsLiveCast = _avCastMgr.publishLiveCast ( true, true, _camera );
					
					if ( _nsLiveCast != null )
					{
						_DebugOut ( 'Live cast published.' );
						// Attach camera output
						callLater ( _LiveCastCheckSize );
					}
					else
					{
						_DebugOut ( 'Live cast publish attempt returned null stream.' );
					}
				}
				catch ( e:Error )
				{
					_DebugOut ( 'Live cast publish attempt error: ' + e.message );
				}
			}
			
			private function _LocalFilesInitialize ( ) : void
			{
				// storage directory
				_dirStorage = File.applicationStorageDirectory;
				
				// defaults
				var sName:String = 'Sasha';
				var iCamIdx:int = -1; // camera selection logic will ignore this as invalid
				_cameraConfigActive = new CameraConfig ( );
				
				// get settings from previous session, if exist
				if ( _UserStateRestore ( ) )
				{
					if ( !_userState.cameraConfigDefault )
					{
						_userState.cameraConfigDefault = _cameraConfigActive;
					}
					if ( isNaN ( _userState.cameraIndex ) )
					{
						_userState.cameraIndex = iCamIdx;
					}
					if ( !_userState.roverName || _userState.roverName.length < 1 )
					{
						_userState.roverName = sName;
					}
				}
				else
				{
					_userState = new UserState ( );
					_userState.cameraConfigDefault = _cameraConfigActive;
					_userState.cameraIndex = iCamIdx;
					_userState.roverName = sName;
				}
				_bArduinoTypeAdb = _userState.arduinoTypeAdb;
				_iArduinoTypeIdx = _bArduinoTypeAdb ? 1 : 0;
				_cameraConfigActive = _userState.cameraConfigDefault;
				_bCamPans = _userState.cameraCanPan;
				_bCamTilts = _userState.cameraCanTilt;
			}
			
			private function _LoginAttempt ( userName:String = '', password:String = null, zoneName:String = null, params:ISFSObject = null ) : void
			{
				currentState = 'login_wait';
				_sRoverPass = password;
				_sf.send ( new LoginRequest ( _oRover.name, password, zoneName, params ) );
			}
			
			private function _LoginForRoomList ( ) : void
			{
				if ( _aRovers != null )
				{
					currentState = 'login_prompt';
				}
				else
				{
					_sf.send ( new LoginRequest ( ) );
				}				
			}
			
			private function _LoginRequest ( event:UtilityEvent ) : void
			{
				var bPersist:Boolean = false;
				if ( _oRover.name != _userState.roverName )
				{
					// user changed rover from default
					_userState.roverName = _oRover.name;
					bPersist = true;
				}
				if ( bPersist )
				{
					callLater ( _UserStatePersist );
				}
				// for now no passwords needed
				_LoginAttempt ( _oRover.name );
			}
			
			private function _Logout ( ) : void
			{
				_sf.send ( new LogoutRequest ( ) );
			}
			
			private function _MotionRequest ( sfso:ISFSObject ) : void
			{
				_moveProps = MoveProps.newFromSFSObject ( sfso );
				var bMov:Boolean = _moveProps.isMoving;
				
				// ##### TESTING #####
				_DebugOut ( 'Arduino command unscaled: ' + _moveProps.commandString );
				// ###################
				
				if ( bMov )
				{
					// scale request to limits
					var mpScaled:MoveProps = _MotionRequestScale ( );
					
					// ##### TESTING #####
					_DebugOut ( 'Arduino command scaled: ' + mpScaled.commandString );
					// ###################
					
					_fArduinoSend ( mpScaled.commandBytes );
				}
				else
				{
					_fArduinoSend ( _moveProps.commandBytes );
				}
				
				if ( _bMoving != bMov )
				{
					// update camera config
					isMoving = !_bMoving;
				}
			}
			
			private function _MotionRequestScale ( ) : MoveProps
			{
				var mp:MoveProps = _moveProps.clone ( );
				if ( _moveProps.isMovingLeft )
					mp.leftSpeed = _iDcMin + Math.round ( _moveProps.leftSpeed * _nDcScale );
				if ( _moveProps.isMovingRight )
					mp.rightSpeed = _iDcMin + Math.round ( _moveProps.rightSpeed * _nDcScale );
				return mp;
			}
			
			private function _MotorLimitsRequest ( sfso:ISFSObject ) : void
			{
				var ml:MotorLimits = MotorLimits.newFromSFSObject ( sfso );
				var iDcMinOld:int = _iDcMin;
				var iDcTopOld:int = _iDcTop;
				_iDcMin = ml.dcMin;
				_iDcTop = ml.dcTop;
				if ( iDcMinOld != _iDcMin || iDcTopOld != _iDcTop )
				{
					_nDcScale = ( _iDcTop - _iDcMin ) / 255;
					if ( _bMoving )
					{
						// rescale latest requested speed to new range
						var mp:MoveProps = _MotionRequestScale ( );
						// ##### TESTING #####
						_DebugOut ( 'Arduino moveProps rescaled: ' + mp.commandString );
						// ###################
						_fArduinoSend ( mp.commandBytes );
					}
				}
			}
			
			private function _NoOp ( arg:* ) : void { }
			
			private function _PingReceived ( sfso:ISFSObject ) : void
			{
				var ping:Ping = Ping.newFromSFSObject ( sfso );
				ping.robotTimeStamp = new Date().getTime();
				ping.robotLagSfs = _iSfsLagRT;
				callLater ( _Pong, [ ping ] );
			}
			
			private function _Pong ( ping:Ping ) : void
			{
				_WatchDogIntervalSet ( ping.intervalMsecs );
				_sf.send ( new PrivateMessageRequest ( 'pong', _iPilotUserId, ping.toSFSObject() ) );
			}
			
			private function _SendUserVars ( vars:Array ) : void
			{
				_sf.send ( new SetUserVariablesRequest ( vars ) );
			}
			
			private function _SfsConfigLoadFailure ( event:SFSEvent ) : void
			{
				_DebugOut ( 'SFS Config Load Failed' );
				currentState = 'connect_prompt';
			}
			
			private function _SfsConfigLoadSuccess ( event:SFSEvent ) : void
			{
				_DebugOut ( 'SFS Config Load Success!' );
				_DebugOut ( 'SFS Settings: ' + _sf.config.host + ':' + _sf.config.port );
				Security.loadPolicyFile ( 'xmlsocket://' + _sf.config.host + ':' + _sf.config.port );
				callLater ( _SfsConnect );
			}
			
			private function _SfsConnect ( ) : void
			{
				_SfsConnectTimerStart ( );
				_sf.connect ( _sf.config.host, _sf.config.port );
				currentState = 'connect_wait';
			}
			
			private function _SfsConnectManual ( ) : void
			{
				var sHost:String = tinSfsHost.text;
				var iPort:int = parseInt ( tinSfsPort.text );
				_sf.config.host = sHost;
				_sf.config.udpHost = sHost;
				_sf.config.port = iPort;
				_sf.config.udpPort = iPort;
				_sf.config.zone = tinSfsZone.text;
				Security.loadPolicyFile ( 'xmlsocket://' + sHost + ':' + iPort );
				callLater ( _SfsConnect );
			}
			
			private function _SfsConnectHostInit ( ) : void
			{
				if ( _sf && _sf.config )
				{
					tinSfsHost.text = _sf.config.host;
					tinSfsPort.text = _sf.config.port.toString();
					tinSfsZone.text = _sf.config.zone;
				}
			}
			
			private function _SfsConnectTimeout ( event:TimerEvent ) : void
			{
				_SfsConnectTimerStop ( );
				_sf.disconnect ( );
				_DebugOut ( 'SFS connection attempt timed out' );
				currentState = 'connect_prompt';
			}
			
			private function _SfsConnectTimerStart ( ) : void
			{
				_tmrConnect.reset ( );
				_tmrConnect.start ( );
			}
			
			private function _SfsConnectTimerStop ( ) : void
			{
				_tmrConnect.stop ( );
			}
			
			private function _SfsConnection ( event:SFSEvent ) : void
			{
				_SfsConnectTimerStop ( );
				if ( event.params.success )
				{
					_DebugOut ( 'SFS Connected!' );
					callLater ( _LoginForRoomList );
					// 
				}
				else
				{
					_DebugOut ( 'SFS Connection Failed: ' + event.params.errorMessage );
					currentState = 'connect_prompt';
				}
			}
			
			private function _SfsConnectionLost ( event:SFSEvent ) : void
			{
				_SfsConnectTimerStop ( );
				_sConnectPrompt = resourceManager.getString ( 'default', 'error_connection' ) + ' ' + event.params.reason;
				_LiveCastClear ( );
				_AvCastMgrDismiss ( );
				currentState = 'connect_prompt';
			}
			
			private function _SfsJoinFailure ( event:SFSEvent ) : void
			{
				_DebugOut ( 'SFS Rover Join Failed: ' + event.params.errorMessage );
				
				// ##### TODO
			}
			
			private function _SfsJoinSuccess ( event:SFSEvent ) : void
			{
				var sName:String = event.params.room.name;
				if ( sName != _userState.roverName )
				{
					_userState.roverName = sName;
					callLater ( _UserStatePersist );
				}
				callLater ( _InitialVariablesReport );
				_DebugOut ( 'SFS Rover Join Success: ' + sName );
				
				// now onward to the video feed
				_AvCastMgrInit ( );
				_sf.enableLagMonitor ( true );
			}
			
			private function _SfsLagMonitorUpdate ( event:SFSEvent ) : void
			{
				_iSfsLagRT = event.params.lagValue;
			}
			
			private function _SfsLoginFailure ( event:SFSEvent ) : void
			{
				_DebugOut ( 'SFS Login Failed: ' + event.params.errorMessage );
				if ( currentState == 'login_wait' )
				{
					currentState = 'login_prompt';
				}
				else
				{
					// ##### TODO
				}
			}
			
			private function _SfsLoginSuccess ( event:SFSEvent ) : void
			{
				// _DebugOut ( 'SFS Login Success: ' + event.params.user.name );
				if ( currentState == 'login_wait' )
				{
					// now logged in with correct name
					currentState = 'join_wait';
					_sf.send ( new JoinRoomRequest ( _oRover.name ) );
				}
				else
				{
					// temp logged in to zone as guest just to get list of rovers (rooms)
					_aRovers = _sf.roomList;
					if ( _aRovers.length > 0 )
					{
						for each ( var i_oRover:SFSRoom in _aRovers )
						{
							if ( i_oRover.name == _userState.roverName )
							{
								_oRover = i_oRover;
								break;
							}
						}
						if ( _oRover == null )
							_oRover = _aRovers [ 0 ];
						
						_alRovers = new ArrayList ( _aRovers );
						callLater ( _Logout );
					}
					else
					{
						// ##### TODO
					}
				}
				
			}
			
			private function _SfsLogoutDone ( event:SFSEvent ) : void
			{
				currentState = 'configure';
			}
			
			private function _SfsPrivateMessageReceived ( event:SFSEvent ) : void
			{
				var sender:User = event.params.sender;
				if ( sender != _sf.mySelf )
				{
					// ##### TODO
					// validate id so control messages are only accepted from pilot
					_iPilotUserId = sender.id;
					
					var sMsg:String = event.params.message;
					if ( sMsg == 'ping' )
					{
						// no need to flood debugout with these
						_PingReceived ( event.params.data );
					}
					else
					{
						if ( _bDebug )
						{
							if ( event.params.data )
							{
								_DebugOut ( 'Private msg from ' + sender.name + ': ' + sMsg + '\n' + ( event.params.data as ISFSObject ).getHexDump(), '' );
							}
							else
							{
								_DebugOut ( 'Private msg from ' + sender.name + ': ' + sMsg );
							}
						}
						
						if ( sMsg == 'mv' )
						{
							_MotionRequest ( event.params.data );
						}
						else if ( sMsg == 'ml' )
						{
							_MotorLimitsRequest ( event.params.data );
						}
						else if ( sMsg == 'cm' )
						{
							_CameraMoveRequest ( event.params.data );
						}
						else if ( sMsg == 'ch' )
						{
							_CameraHomeRequest ( );
						}
						else if ( sMsg == 'cameraconfig' )
						{
							_CameraConfigRequest ( event.params.data );
						}
						else if ( sMsg == 'cameraconfigadjust' )
						{
							_CameraConfigAdjustRequest ( event.params.data );
						}
						else if ( sMsg == 'cameraconfigdef' )
						{
							_CameraConfigDefaultRequest ( event.params.data );
						}
						else if ( sMsg == 'cameraconfigmotion' )
						{
							_CameraConfigMotionRequest ( event.params.data );
						}
						else if ( sMsg == 'camerafpspollmsec' )
						{
							_CameraFpsPollRequest ( event.params.data );
						}
						else
						{
							_DebugOut ( 'Unexpected message: ' + sMsg );
						}						
					}
					_WatchDogReset ( );
				}
			}
			
			private function _TelemetryInFromPrimavera ( event:RoverEvent ) : void
			{
				_TelemetryReceived ( event.roverData );
			}
			
			private function _TelemetryInFromServerSocket ( event:SocketBytesEvent ) : void
			{
				_TelemetryReceived ( event.bytes );
			}
			
			private function _TelemetryReceived ( bytes:ByteArray ) : void
			{
				bytes.position = 0;
				// NOTE: ByteArray automatically changes its position property to the index immediately after the latest read or write operation.
				//       The bytesAvailable property contains the number of bytes left between the current position and the end.
				var aVarsToSend:Array = [];
				var iLoops:int = 0;
				var nDatum:Number;
				var uDatum:uint;
				
				// label the while loop so can break all the way out from within the switch case statement
				commandLoop: while ( bytes.bytesAvailable > 2 )
				{
					if ( ++iLoops > 50 )
					{
						_DebugOut ( '_SsaBytesReceived loop count exceeded' );
						break;
					}
					switch ( bytes.readUnsignedByte ( ) as uint )
					{
						case 0x1:
							// motor 1 current
							uDatum = bytes.readUnsignedShort ( ) * 34;
							if ( uDatum != _roverData.motor1Current )
							{
								// aData.push ( new SFSUserVariable ( 'TBD', uDatum ) );
								_roverData.motor1Current = uDatum;
							}
							break;
						case 0x2:
							// motor 2 current
							uDatum = bytes.readUnsignedShort ( ) * 34;
							if ( uDatum != _roverData.motor2Current )
							{
								// aData.push ( new SFSUserVariable ( 'TBD', uDatum ) );
								_roverData.motor2Current = uDatum;
							}
							break;
						case 0x3:
							// temperature
							nDatum = ( Number ( bytes.readUnsignedShort ( ) ) * 500.0 / 1024.0 ) * 9.0 / 5.0 + 32.0;
							if ( nDatum != _roverData.temperature )
							{
								aVarsToSend.push ( new SFSUserVariable ( 'btm', nDatum ) );
								_roverData.temperature = nDatum;
							}
							break;
						case 0x4:
							// ultrasonic ranger left
							uDatum = bytes.readUnsignedShort ( );
							if ( uDatum != _roverData.usRangeLeft )
							{
								aVarsToSend.push ( new SFSUserVariable ( 'usl', uDatum ) );
								_roverData.usRangeLeft = uDatum;
							}
							break;
						case 0x5:
							// ultrasonic ranger right
							uDatum = bytes.readUnsignedShort ( );
							if ( uDatum != _roverData.usRangeRight )
							{
								aVarsToSend.push ( new SFSUserVariable ( 'usr', uDatum ) );
								_roverData.usRangeRight = uDatum;
							}
							break;
						case 0x6:
							// electronics battery
							nDatum = Number ( bytes.readUnsignedShort ( ) ) / 1024;
							uDatum = uint ( Math.round ( 100 * nDatum ));
							if ( uDatum != _roverData.cleanBat )
							{
								aVarsToSend.push ( new SFSUserVariable ( 'cbt', uDatum ) );
								_roverData.cleanBat = uDatum;	
							}
							break;
						case 0x7:
							// motor battery
							/*nDatum = Number ( bytes.readUnsignedShort ( ) ) * 5.0 * 1.6 / 1024.0;
							uDatum = uint ( Math.floor ( 100 * ( nDatum - 9 ) / 3 ) );
							*/
							nDatum = Number ( bytes.readUnsignedShort ( ) ) / 1024;
							uDatum = uint ( Math.round ( 100 * nDatum ));
							if ( uDatum != _roverData.dirtyBat )
							{
								aVarsToSend.push ( new SFSUserVariable ( 'dbt', uDatum ) );
								_roverData.dirtyBat = uDatum;	
							}
							break;
						case 0x8:
							// pan and tilt
							//   pan
							uDatum = bytes.readUnsignedByte ( );
							if ( uDatum != _roverData.panAngle )
							{
								// aDataToSend.push ( new SFSUserVariable ( 'TBD', uDatum ) );
								_roverData.panAngle = uDatum;
							}
							//   tilt
							uDatum = bytes.readUnsignedByte ( );
							if ( uDatum != _roverData.tiltAngle )
							{
								// aDataToSend.push ( new SFSUserVariable ( 'TBD', uDatum ) );
								_roverData.tiltAngle = uDatum;
							}
							break;
						default:
							_DebugOut ( '_SsaBytesReceived unknown command' );
							// no way to know what should come next, so break completely out of the while loop
							break commandLoop;
					}
				}
				
				if ( aVarsToSend.length > 0 )
				{
					_sf.send ( new SetUserVariablesRequest ( aVarsToSend ) );
				}
			}
			
			private function _UserStatePersist ( ) : void
			{
				try
				{
					var ba:ByteArray = new ByteArray ( );
					ba.writeObject ( _userState );
					
					var f:File = _dirStorage.resolvePath ( 'UserState.dat' );
					if ( f.exists ) f.deleteFile ( );
					
					var fs:FileStream = new FileStream();
					// open
					fs.open ( f, FileMode.WRITE );
					// write
					fs.writeBytes ( ba );
					// close
					fs.close();
				}
				catch ( err:* )
				{
					_DebugOut ( err );
				}
				
			}
			
			private function _UserStateRestore ( ) : Boolean
			{
				registerClassAlias ( 'UserState', UserState as Class );
				registerClassAlias ( 'CameraConfig', CameraConfig as Class );
				
				var f:File = _dirStorage.resolvePath ( 'UserState.dat' );
				if ( !f.exists ) return false; // not yet saved locally
				
				var fs:FileStream = new FileStream();
				// open
				fs.open ( f, FileMode.READ );
				// read
				var ba:ByteArray = new ByteArray();
				fs.readBytes ( ba );
				// close
				fs.close();
				
				try
				{
					_userState = ba.readObject ( );
				}
				catch ( err:* )
				{
					_DebugOut ( err );
					return false;
				}
				
				return true;
			}
			
			private function _WatchDogBark ( event:TimerEvent ) : void
			{
				// Watch dog timer lapsed.
				_DebugOut ( 'Watch dog bark [' + _tmrDog.delay + ' msecs]' );
				
				// ##### TODO
				// Stop any movement until next request.
				
				// #####
				
				// Report to pilot.
				_EmergencyStopReport ( EmergencyCodes.WATCHDOG );
			}
			
			private function _WatchDogIntervalSet ( pingIntervalMsecs:int ) : void
			{
				// allow a cushion on top of time until next expected ping
				var iNew:int = pingIntervalMsecs * 1.5 + _iSfsLagRT;
				if ( _tmrDog.delay != iNew )
					_tmrDog.delay = iNew;
			}
			
			private function _WatchDogReset ( ) : void
			{
				_tmrDog.reset ( );
				_tmrDog.start ( );
			}
			
			//----------------------------Tuan-----------------------------------------
			// Funcionality of this listener moved to _SfsPrivateMessageReceived
			// on 7/5/2013 by gch.
			//Send command to control Rover
			/*
			private function _onCommand (event:SFSEvent) : void
			{
			var sender:User = event.params.sender;
			if (sender != _sf.mySelf && event.params.message != "ping")
			{
			_arduino.sendComand(event.params.message);
			_DebugOut ( '_onCommand msg from ' + sender.name + ': ' + event.params.message);
			// var ni:NotificationInterface = new NotificationInterface();
			// ni.notify(event.params.message);
			}
			}
			*/
			//------------------------------------------------------------------------
			//---------------Tuan Code----------------------------------
			// Receive data from the Rover and send to User Client
			// User Variable: bodytemp, usrangeleft, usrangeright
			/*
			private function onData( event:RoverEvent ):void 
			{
				
				// convert string back to byte array
				var data:Array = event.roverData.split(",");
				if (data.length > 0) {
					var loop_count:int = 0;  // ****************************
					var datum:uint;
					var i:int = 0;
					var dataArray:Array = [];
					while (i < data.length) {
						loop_count++;
						if (loop_count > 50) {
							_DebugOut("endless loop"); 
							break;
						}
						var len:int = data.length - i;
						switch (uint(data[i])) {
							case 0x1:
								// motor 1 current
								if (len >= 3) {
									datum = composeInt(data[i+1], data[i+2])*34;
									if (datum != _roverData.motor1Current){
										// dataArray.push(new SFSUserVariable("tbd",datum));
										_roverData.motor1Current = datum;
									}
								}
								i += 3;
								break;
							case 0x2:
								// motor 2 current
								if (len >= 3) {
									datum = composeInt(data[i+1], data[i+2])*34;
									if (datum != _roverData.motor2Current){
										// dataArray.push(new SFSUserVariable("tbd",datum));
										_roverData.motor2Current = datum 
									}
								}
								i += 3;
								break;
							case 0x3:
								// Temperature
								if (len >= 3) {
									_roverData.temperature = (Number(composeInt(data[i+1], data[i+2]))*500.0/1023.0)*9.0/5.0+32.0;
									if (datum != _roverData.temperature){
										dataArray.push(new SFSUserVariable("btm",datum));
										_roverData.temperature = datum;
									}
								}
								i += 3;
								break;
							case 0x4:
								// ultrasonic ranger left
								if (len >= 3) {
									datum = (composeInt(data[i+1], data[i+2]));
									if (datum != _roverData.usRangeLeft){
										dataArray.push(new SFSUserVariable("usl", datum));
										_roverData.usRangeLeft = datum;
									}
								}
								i += 3;
								break;
							case 0x5:
								// ultrasonic ranger right
								if (len >= 3) {
									datum = (composeInt(data[i+1], data[i+2]));
									if (datum != _roverData.usRangeRight){
										dataArray.push(new SFSUserVariable("usr", datum));					
										_roverData.usRangeRight = datum;
									}
								}
								i += 3;
								break;
							case 0x6:
								// electronics battery
								if (len >= 3) {
									datum = Number(composeInt(data[i+1], data[i+2]))*5.0*2.8/1024.0;
									datum = Math.floor(((datum-9)/3)*100);
									if (datum != _roverData.cleanBat){
										dataArray.push(new SFSUserVariable("cbt", datum));
										_roverData.cleanBat = datum;	
									}
								}
								i += 3;
								break;
							case 0x7:
								// motor battery
								if (len >= 3) {
									datum = Number(composeInt(data[i+1], data[i+2]))*5.0*1.6/1024.0;
									datum = Math.floor(((datum-6)/2)*100);
									if (datum != _roverData.dirtyBat)
									{
										dataArray.push(new SFSUserVariable("dbt", datum));
										_roverData.dirtyBat = datum;
									}
								}
								i += 3;
								break;
							
							case 0x8:
								// pan and tilt
								if (len >= 3) {
									_roverData.panAngle = uint(data[i+1]); // 32-bit unsigned int
									_roverData.tiltAngle = uint(data[i+2]);
								}
								i += 3;
								break;
							
							default:
								_DebugOut("ArxRover Main: Unknown Command"); 
								i = len;
								break;
						}
					}
					if (dataArray.length > 0){
						_sf.send(new SetUserVariablesRequest(dataArray));
					}
				}
				
			}
			
			private function composeInt(hi:String, lo:String):uint
			{
				var val:uint = uint (hi) & 0x000000FF;
				val = val << 8;           // val *= 256;
				val += uint (lo) & 0x000000FF;
				return val;
			}
			*/
			
			//---------------------------------------------------------------------------------------------
			
			
		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<s:states>
		<s:State name="connect_wait" stateGroups="busy" />
		<s:State name="connect_prompt" />
		<s:State name="configure" />
		<s:State name="login_prompt" stateGroups="login" />
		<s:State name="login_wait" stateGroups="login, busy" />
		<s:State name="join_wait" stateGroups="busy" />
		<s:State name="livecast_wait" stateGroups="busy" />
		<s:State name="pilot" stateGroups="live" />
		<s:State name="tech" stateGroups="live" />
	</s:states>
	<mx:UIComponent
		id="uicVideo"
		visible="{_bLiveCastMonitor}"
		left="{_iVideoMonLeft}"
		top="{_iVideoMonTop}"
		width="{_iVideoMonWd}"
		height="{_iVideoMonHt}"
		/>
	<s:BusyIndicator
		id="bi"
		includeIn="busy"
		horizontalCenter="0"
		verticalCenter="0"
		/>
	<s:VGroup
		id="gpConnect"
		includeIn="connect_prompt"
		horizontalCenter="0"
		top="8"
		horizontalAlign="center"
		creationComplete="_SfsConnectHostInit()"
		>
		<s:Label
			id="lblSfsConnect"
			styleName="colorLight"
			maxDisplayedLines="-1"
			text="{_sConnectPrompt}"
			/>
		<s:TextInput
			id="tinSfsHost"
			/>
		<s:TextInput
			id="tinSfsPort"
			/>
		<s:TextInput
			id="tinSfsZone"
			/>
		<s:Button
			id="btnConnect"
			label="{resourceManager.getString('default','connect_btn_label')}"
			click="_SfsConnectManual()"
			horizontalCenter="0"
			verticalCenter="0"
			/>
	</s:VGroup>
	<vw:ChatView
		id="vwChat"
		includeIn="live"
		top="{_bOsIsAndroid?48:8}"
		right="8"
		width="{_iChatWd}"
		height="{_iChatHt}"
		rover="{_oRover}"
		sfs="{_sf}"
		/>
	<s:TextArea
		id="taDebug"
		skinClass="spark.skins.mobile.TextAreaSkin"
		visible="{_bDebug}"
		bottom="8"
		height="90%"
		left="8"
		right="{gpBtnDebug.width + 16}"
		editable="false"
		selectable="false"
		/>
	<s:VGroup
		id="gpBtnDebug"
		bottom="8"
		right="8"
		gap="4"
		horizontalAlign="left"
		>
		<s:Button
			label="{resourceManager.getString('default','clear_btn_label')}"
			click="{taDebug.text=''}"
			visible="{_bDebug}"
			/>
		<s:Spacer
			height="12"
			/>
		<s:Label
			text="{resourceManager.getString('default','debug_btn_label')}"
			/>
		<comp:ToggleSwitchCustom
			id="btnDebug"
			skinClass="{skins.ToggleSwitchCustomSkin}"
			selectedLabel="{resourceManager.getString('default','on_label')}"
			unselectedLabel="{resourceManager.getString('default','off_label')}"
			selected="@{_bDebug}"
			/>
	</s:VGroup>
	<s:VGroup
		id="gpLeft"
		includeIn="live"
		gap="16"
		left="8"
		top="8"
		horizontalAlign="left"
		>
		<comp:RoverCamInfo
			id="rcInfo"
			camera="{_camera}"
			monitorLiveCast="{_bLiveCastMonitor}"
			monitorLiveCastFull="{_bLiveCastMonFull}"
			monitor_toggle="_LiveCastMonitorToggle()"
			monitor_full_toggle="_LiveCastMonitorFullToggle()"
			/>
		<!--
		<vw:TelemetryTestView
			id="vwTelemetry"
			sfs="{_sf}"
			/>
		-->
	</s:VGroup>
	<vw:ConfigView
		id="vwConfig"
		includeIn="configure"
		horizontalCenter="0"
		top="8"
		arduinoTypeIdx="@{_iArduinoTypeIdx}"
		arduinoTypesList="{_alArduinoTypes}"
		camera="@{_camera}"
		cameraCanPan="@{_bCamPans}"
		cameraCanTilt="@{_bCamTilts}"
		camerasList="{_alCameras}"
		configure="_ApplicationConfigure()"
		/>
	<vw:RoverLoginView
		id="vwLogin"
		includeIn="login"
		enabled="true"
		enabled.login_wait="false"
		horizontalCenter="0"
		top="8"
		rover="@{_oRover}"
		roversList="{_alRovers}"
		login="_LoginRequest(event)"
		/>
	<s:Button
		id="btnExit"
		visible="{_bOsIsAndroid}"
		includeInLayout="{_bOsIsAndroid}"
		right="8" top="8"
		label="{resourceManager.getString('default','exit_btn_label')}"
		click="{_Exit()}"
		/>
	
</s:Application>
