package controllers
{
	import com.distriqt.extension.battery.events.BatteryEvent;
	import com.distriqt.extension.gyroscope.events.GyroscopeEvent;
	
	import flash.desktop.NativeApplication;
	import flash.desktop.SystemIdleMode;
	import flash.display.StageDisplayState;
	import flash.display.StageOrientation;
	import flash.events.Event;
	import flash.events.GeolocationEvent;
	import flash.events.KeyboardEvent;
	import flash.events.StageOrientationEvent;
	import flash.events.TimerEvent;
	import flash.filesystem.File;
	import flash.filesystem.FileMode;
	import flash.filesystem.FileStream;
	import flash.media.Camera;
	import flash.media.Video;
	import flash.net.registerClassAlias;
	import flash.sensors.Geolocation;
	import flash.system.Capabilities;
	import flash.ui.Keyboard;
	import flash.ui.Multitouch;
	import flash.ui.MultitouchInputMode;
	import flash.utils.ByteArray;
	import flash.utils.Timer;
	
	import mx.core.UIComponent;
	import mx.events.ResizeEvent;
	
	import spark.components.Application;
	
	import away3d.core.math.MathConsts;
	
	import events.DialogEvent;
	import events.StatusDataEvent;
	import events.TelemetryEvent;
	import events.UtilityEvent;
	
	import interfaces.IMcuConnector;
	import interfaces.IPilotConnector;
	
	import org.apache.flex.collections.VectorCollection;
	
	import utils.BatteryUtil;
	import utils.DeclinationUtil;
	import utils.FlagsUtil;
	import utils.GyroUtil;
	import utils.HexStringUtil;
	import utils.McuConnector;
	import utils.McuConnectorBluetooth;
	import utils.McuConnectorPrimavera;
	import utils.McuConnectorSocket;
	import utils.NonUIComponentBase;
	import utils.PilotConnector;
	import utils.PilotConnectorCS;
	import utils.PilotConnectorPP;
	import utils.PilotConnectorRC;
	
	import vo.CameraConfig;
	import vo.CameraMove;
	import vo.CoordinatesMessage;
	import vo.CurrentCoordinates;
	import vo.CustomCommandConfig;
	import vo.DialogData;
	import vo.DialogOption;
	import vo.EmergencyFlags;
	import vo.Gps;
	import vo.McuConnectModes;
	import vo.McuEeprom;
	import vo.McuMessage;
	import vo.MessageByteArray;
	import vo.MessageData;
	import vo.MotorStates;
	import vo.MoveProps;
	import vo.OpModes;
	import vo.RoverData;
	import vo.StatusData;
	import vo.UserState;
	
	[Event(name="app_resized", type="flash.events.Event")]
	[Event(name="app_view_state_changed", type="flash.events.Event")]
	[Event(name="op_mode_changed", type="flash.events.Event")]
	[Event(name="rotation_lock_changed", type="flash.events.Event")]
	[Event(name="sleep_state_changed", type="flash.events.Event")]
	
	[Event(name="status_data_message", type="events.StatusDataEvent")]
	[Event(name="status_bg_message", type="events.StatusDataEvent")]
	
	/**
	 * Controls data acquisition and persistence, interactions with
	 * the host device, user session persistence, etc. Provides a
	 * singleton that all views can access to get their data.
	 */
	public class SessionManager extends NonUIComponentBase
	{
		// CONSTANTS
		
		//   event types
		public static const APP_RESIZED:String = 'app_resized';
		public static const APP_VIEW_STATE_CHANGED:String = 'app_view_state_changed';
		public static const OP_MODE_CHANGED:String = 'op_mode_changed';
		public static const ROTATION_LOCK_CHANGED:String = 'rotation_lock_changed';
		public static const SLEEP_STATE_CHANGED:String = 'sleep_state_changed';
		
		//   timer defaults
		//     Battery check updates a user variable as least this often when in sleep mode
		//     (and all the time when testing with iOS).  The timer delay must be less than
		//     the maximum user idle time (currently 1000 seconds) we have set in the
		//     SmartFoxServer configuration for the Arx zone.
		public static const BATTERY_CHECK_MSECS:Number = 900000;
		public static const EEPROM_READ_LIMIT:Number = 1000;
		public static const EEPROM_WRITE_INTERVAL:Number = 500; // multiplied by number of bytes to be written
		public static const NAV_GPS_MSEC_DEFAULT:Number = 5000;
		public static const NAV_HDG_MSEC_DEFAULT:Number = 5000;
		
		//   layout
		public static const PHI_MAJOR:Number = 0.5 * ( Math.sqrt ( 5 ) + 1 ); // Golden Ratio
		public static const PHI_MINOR:Number = PHI_MAJOR - 1;
		public static const PHI_MINOR_SQ:Number = PHI_MINOR * PHI_MINOR;
			
		//   os
		public static const OS_OTHER:int = 0;
		public static const OS_ANDROID:int = 1;
		public static const OS_IOS:int = 2;
		public static const OS_BLACKBERRY:int = 3;
		
		private static const _VIEW_STATE_RANKS:Object = {
			'home': 0,
			'home_cs': 0,
			'home_pp': 0,
			'home_rc': 0,
			'bluetooth_config': 5,
			'connect_prompt_cs': 4,
			'custom_config': 1,
			'eeprom_config': 1,
			'login_prompt_cs': 3,
			'mode_prompt': 0,
			'phone_config': 2
		};
		
		// CONSTRUCTOR AND INSTANCE
		
		/**
		 * Singleton: use static property <b>instance</b> to get a reference.
		 */
		public function SessionManager(enforcer:SingletonEnforcer)
		{
			super();
		}
		
		/**
		 * Singleton instance of SessionManager
		 */
		public static function get instance ( ) : SessionManager
		{
			if ( !__instance )
			{
				__instance = new SessionManager ( new SingletonEnforcer ( ) );
			}
			return __instance;
		}
		
		private static var __instance:SessionManager;
		
		
		// PUBLIC PROPERTIES AND GET/SET METHOD GROUPS
		
		[Bindable]
		public var actionMenuBgColor:uint = 0x666666;
		[Bindable]
		public var actionMenuBtnStyleName:String;
		[Bindable]
		public function get actionMenuOn():Boolean
		{
			return _bActMnOn;
		}
		public function set actionMenuOn(value:Boolean):void
		{
			_bActMnOn = value;
			if ( value )
			{
				dispatchEvent (
					new StatusDataEvent (
						StatusDataEvent.STATUS_BG_MESSAGE,
						new StatusData ( appVersion )
					)
				);
			}
			else
			{
				dispatchEvent (
					new StatusDataEvent (
						StatusDataEvent.STATUS_BG_MESSAGE
					)
				);
			}
		}

		public var app:Application;
		[Bindable]
		public var appVersion:String;
		private var _sAppVwState:String = 'home';
		[Bindable (event="app_view_state_changed")]
		public function get appViewState():String
		{
			return _sAppVwState;
		}
		private function _AppViewStateSet(value:String):void
		{
			if ( _sAppVwState !== value )
			{
				_sAppVwState = value;
				dispatchEvent(new Event('app_view_state_changed'));
			}
		}
		public function get batteryPct():Number
		{
			return _nBatteryPct;
		}
		public function get batterySupported():Boolean
		{
			return _bBatterySupport;
		}
		[Bindable]
		public var customCommandInnerWidth:Number = 144;
		[Bindable]
		public var customCommandOuterWidth:Number = 160;
		[Bindable]
		public function get debugOn():Boolean
		{
			return _bDebug;
		}
		public function set debugOn(value:Boolean):void
		{
			_bDebug = value;
		}
		[Bindable]
		public function get debugVisible ( ) : Boolean
		{
			return _bDebugVis;
		}
		public function set debugVisible (value:Boolean) : void
		{
			_bDebugVis = value;
			if ( !value )
			{
				debugOn = false;
			}
		}
		public function get eepromsCollection ( ) : VectorCollection
		{
			return new VectorCollection ( _vEeproms );
		}
		public var eepromConfigCaptRsrc:String;
		public var eepromWriteCaptRsrc:String;
		[Bindable]
		public var expertModeOn:Boolean = true;
		// eventually plan to change these at runtime as needed for DPI
		[Bindable]
		public var guiGap:Number = 8;
		[Bindable]
		public var guiGap2:Number = 2 * guiGap;
		[Bindable]
		public var guiGap3:Number = 3 * guiGap;
		[Bindable]
		public var guiGap4:Number = 4 * guiGap;
		[Bindable]
		public var isBusy:Boolean = true;
		public function get isMoving():Boolean
		{
			return _bMoving;
		}
		private function _IsMovingSet(value:Boolean):void
		{
			_bMoving = value;
			_camMgr.motionSet ( _bMoving );
		}
		[Bindable (event="sleep_state_changed")]
		public function get isSleeping():Boolean
		{
			return _bSleep;
		}
		private function _IsSleepingSet(value:Boolean):void
		{
			if ( _bSleep !== value )
			{	
				_bSleep = value;
				dispatchEvent ( new Event ( SLEEP_STATE_CHANGED ) );
			}
		}
		[Bindable]
		public var lightExternal:Boolean = false;
		[Bindable]
		public var lightOn:Boolean = false;
		[Bindable]
		public var mcuBluetooth:McuConnectorBluetooth;
		public function get mcuConnected():Boolean
		{
			return _bMcuConnected;
		}
		private function _McuConnectedSet(value:Boolean):void
		{
			if ( _bMcuConnected !== value )
			{
				_bMcuConnected = value;
				if ( value )
				{
					debugOut ( 'status_mcu_connected', true );
					if ( _bEepromsNeeded )
					{
						// attempt read now
						_bEepromsNeeded = false;
						var i_eep:McuEeprom = _oEepromById [ 'eepv' ] as McuEeprom;
						if ( mcuSendCommandByteArray ( i_eep.messageBytesForRead ) )
						{
							_EepromReadTimerReset ( );
							statusSetResource ( 'status_eeprom_read' );
						}
						else
						{
							_EepromReadTimedOut ( );
						}
					}
				}
				else
				{
					debugOut ( 'error_mcu_disconnected', true );
				}
			}
		}
		[Bindable]
		public var mcuConnector:IMcuConnector;
		public function get moveIgnore():Boolean
		{
			return _bMoveIgnore;
		}
		private function _MoveIgnoreSet(value:Boolean):void
		{
			_bMoveIgnore = value;
		}
		[Bindable]
		public var orientedPortrait:Boolean = true;
		[Bindable (event="op_mode_changed")]
		public function get opMode():uint
		{
			return _uOpMode;
		}
		private function _OpModeSet(value:uint):void
		{
			if ( _uOpMode !== value )
			{
				_uOpMode = value;
				dispatchEvent ( new Event ( OP_MODE_CHANGED ) );
			}
		}
		public var os:int;
		[Bindable]
		public var osAllowsExit:Boolean = true;
		/**
		 * Do not store this, because it returns a
		 * singleton instance reference that
		 * may become invalid.
		 */
		[Bindable]
		public var pilotConnector:IPilotConnector;
		private var _bRotLock:Boolean = false;
		[Bindable(event="rotation_lock_changed")]
		public function get rotationLocked():Boolean
		{
			return !app.stage.autoOrients;
		}
		private function _RotationLockChangedDispatch():void
		{
			dispatchEvent ( new Event ( ROTATION_LOCK_CHANGED ) );
		}
		public var userState:UserState;
		public var videoPod:UIComponent;
		public function get videoPodAspectRatio():Number
		{
			return _nVidPodAspect;
		}
		public function get videoPodHeight():int
		{
			return _iVidPodHt;
		}
		public function get videoPodWidth():int
		{
			return _iVidPodWd;
		}
		public function get videoSenderRotation():uint
		{
			return _uVidSenderRot;
		}
		
		
		// OTHER PUBLIC METHODS
		
		public function actionMenuToggle ( hardware:Boolean = false ) : void
		{
			actionMenuOn = !actionMenuOn;
		}
		
		public function batchVarsReportQueue ( ) : void
		{
			callLater ( _BatchVarsReport );
		}
		
		public function bluetoothConfigDone ( ) : void
		{
			viewStatePop ( 'bluetooth_config' );
		}
		
		public function bluetoothConfigOpen ( ) : void
		{
			viewStatePush ( 'bluetooth_config' );
		}
		
		public function bluetoothConfigSuccess ( ) : void
		{
			statusSetResource ( 'status_bt_success' );
			bluetoothConfigDone ( );
		}
		
		public function cameraMoveHomeRequest ( ) : void
		{
			if ( _bMoveIgnore )
			{
				debugOut ( 'cameraMoveHomeRequest discarded due to emergency flags: ' + _uEmFlags );
				return;
			}
			
			// ##### TESTING #####
			debugOut ( 'Mcu command: 4' );
			// ###################
			if ( _bPanOrTiltEnabled )
			{
				mcuSendCommandId ( McuMessage.CAMERA_HOME );
				// ##### TESTING #####
				if ( !_bMcuConnected )
				{
					// fake it
					var vmdToSend:Vector.<MessageData> = new <MessageData> [];
					if ( _VisionPanUpdate ( _iPanHome ) )
					{
						vmdToSend.push ( new MessageData ( 'cp', _iPanHome ) );
					}
					if ( _VisionTiltUpdate ( _iTiltHome ) )
					{
						vmdToSend.push ( new MessageData ( 'ct', _iTiltHome ) );
					}
					if ( vmdToSend.length > 0 )
					{
						pilotConnector.userVarsQueue ( vmdToSend );
						_VisionMoveUpdateCommit ( );
					}
				}
				// ###################
			}
		}
		
		public function cameraMoveRequest ( cm:CameraMove ) : void
		{
			if ( _bMoveIgnore )
			{
				debugOut ( 'cameraMoveRequest discarded due to emergency flags: ' + _uEmFlags );
				return;
			}
			
			// ##### TESTING #####
			debugOut ( 'Mcu command: ' + cm.messageString );
			// ###################
			if ( _bPanOrTiltEnabled )
			{
				mcuSendCommandByteArray ( cm.messageBytes );
				// ##### TESTING #####
				if ( !_bMcuConnected )
				{
					// fake it
					var vmdToSend:Vector.<MessageData> = new <MessageData> [];
					if ( _VisionPanUpdate ( cm.panDegrees ) )
					{
						vmdToSend.push ( new MessageData ( 'cp', cm.panDegrees ) );
					}
					if ( _VisionTiltUpdate ( cm.tiltDegrees ) )
					{
						vmdToSend.push ( new MessageData ( 'ct', cm.tiltDegrees ) );
					}
					if ( vmdToSend.length > 0 )
					{
						pilotConnector.userVarsQueue ( vmdToSend );
						_VisionMoveUpdateCommit ( );
					}
				}
				// ###################
			}
		}
		
		public function cameraMoveResetRequest ( ) : void
		{
			if ( _bMoveIgnore )
			{
				debugOut ( 'cameraMoveResetRequest discarded due to emergency flags: ' + _uEmFlags );
				return;
			}
			
			// ##### TESTING #####
			debugOut ( 'Mcu command: 5' );
			// ###################
			if ( _bPanOrTiltEnabled )
			{
				mcuSendCommandId ( McuMessage.CAMERA_RESET );
				// ##### TESTING #####
				if ( !_bMcuConnected )
				{
					// fake it
					var vmdToSend:Vector.<MessageData> = new <MessageData> [];
					if ( _VisionPanUpdate ( _iPanReset ) )
					{
						vmdToSend.push ( new MessageData ( 'cp', _iPanReset ) );
					}
					if ( _VisionTiltUpdate ( _iTiltReset ) )
					{
						vmdToSend.push ( new MessageData ( 'ct', _iTiltReset ) );
					}
					if ( vmdToSend.length > 0 )
					{
						pilotConnector.userVarsQueue ( vmdToSend );
						_VisionMoveUpdateCommit ( );
					}
				}
				// ###################
			}
		}
		
		public function customConfigDone ( ) : void
		{
			viewStatePop ( 'custom_config' );
			callLater ( _CustomConfigValidate );
		}
		
		public function customConfigOpen ( ) : void
		{
			viewStatePush ( 'custom_config' );
		}
		
		public function customRequest ( mba:MessageByteArray ) : void
		{
			if ( _bMoveIgnore )
			{
				debugOut ( 'customRequest discarded due to emergency flags: ' + _uEmFlags );
				return;
			}
			
			// ##### TESTING #####
			if ( _bDebug )
				debugOut ( 'Custom command: ' + mba.messageString );
			// ###################
			
			if ( _custCmdMgr.suspend )
			{
				debugOut ( 'customRequest discarded while Command Configuration in progress.' );
				return;
			}
			
			mcuSendCommandByteArray ( mba.messageBytes );
		}
		
		public function eepromConfigOpen ( ) : void
		{
			// Display capabilities configuration screen.
			viewStatePush ( 'eeprom_config' );
		}
		
		public function eepromConfigUserDone ( ) : void
		{
			viewStatePop ( 'eeprom_config' );
			callLater ( _EepromConfigWrite );
		}
		
		public function emergencyAcknowledge ( ) : void
		{
			// Called when receive message from pilot acknowledging notice of emergency condition.
			// Can indicate that a latency problem has abated and we can resume activity if no other
			// emergency flags are set.
			debugOut ( 'Emergency state acknowledged by Pilot Control Panel' );
			emergencyFlagsClear ( EmergencyFlags.LATENCY );
		}
		
		public function emergencyFlagsClear ( flags:uint, fromMcu:Boolean = false ) : void
		{
			var uFlags:uint = FlagsUtil.Clear ( _uEmFlags, EmergencyFlags.ValidateFlags ( flags ) );
			if ( uFlags != _uEmFlags )
			{
				_uEmFlags = uFlags;
				_EmergencyStateUpdate ( );
			}
		}
		
		public function emergencyFlagsGet ( ) : uint
		{
			return _uEmFlags;
		}
		
		public function emergencyFlagsSet ( flags:uint, fromMcu:Boolean = false ) : void
		{
			var uFlags:uint = FlagsUtil.Set ( _uEmFlags, EmergencyFlags.ValidateFlags ( flags ) );
			if ( uFlags != _uEmFlags )
			{
				_uEmFlags = uFlags;
				_EmergencyStateUpdate ( );
				// #############
				// until Mcu does safe correctly
				var bStop:Boolean = true;
				if ( _uEmFlags == EmergencyFlags.OBSTACLE && ( _moveProps.leftRun == MotorStates.BACKWARD || _moveProps.rightRun == MotorStates.BACKWARD ) )
				{
					bStop = false;
				}
				if ( bStop )
				{
					_moveProps = MoveProps.NewFromParameters ( );
					_IsMovingSet ( false );
					mcuSendCommandByteArray ( _moveProps.messageBytes );
				}
				// #############
				if ( !fromMcu )
				{
					// Mcu safe mode
					mcuSendCommandId ( McuMessage.SAFE_ROVER );
				}
			}
		}
		
		public function exitConfirmed ( ) : void
		{
			if ( osAllowsExit )
			{
				_bExiting = true;
				
				_SystemsDeactivate ( );
				if ( _bBatterySupport )
				{
					_batteryUtil.service.removeEventListener ( BatteryEvent.BATTERY_INFO, _BatteryUpdated );
					_batteryUtil.unregister ( );
					_batteryUtil.dismiss ( );
					_batteryUtil = null;
				}
				
				_McuConnectorDismiss ( );
				
				_PilotConnectorDismiss ( );
				
				callLater ( _ExitStepExit );
			}
		}
		
		public function exitQuery ( ) : void
		{
			eventRelay.dispatchEvent (
				new DialogEvent (
					DialogEvent.DIALOG,
					'exit_confirm_msg',
					'exit_confirm_title',
					null,
					null,
					new DialogData (
						'exit',
						new <DialogOption> [
							new DialogOption ( 'y', 'yes_label' ),
							new DialogOption ( 'n', 'no_label' )
						],
						-1,
						_ExitQueryResponse
					)
				)
			);
		}
		
		public function expertModeToggle ( ) : void
		{
			_ExpertModeSet ( !expertModeOn );
			if ( !actionMenuOn )
			{
				actionMenuOn = true;
			}
		}
		
		public function initialize ( app:Application ) : void
		{
			this.app = app;
			// keep fully awake, until create ANE for Android PARTIAL_WAKE_LOCK
			NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;
			NativeApplication.nativeApplication.addEventListener (
				KeyboardEvent.KEY_DOWN, _KeyDown, false, 0, true
			);
			NativeApplication.nativeApplication.addEventListener (
				KeyboardEvent.KEY_UP, _KeyUp, false, 0, true
			);
			
			var sVer:String = Capabilities.version.substr ( 0, 3 );
			switch ( sVer )
			{
				case ( 'IOS' ):
					os = OS_IOS;
					break;
				case ( 'AND' ):
					os = OS_ANDROID;
					break;
				case ( 'QNX' ):
					os = OS_BLACKBERRY;
					break;
				default:
					os = OS_OTHER;
					break;
			}
			// NativeApplication.nativeApplication.exit() should work on anything except iOS
			osAllowsExit = ( os != OS_IOS );
			if ( os == OS_ANDROID )
			{
				_nRollSign = -_nRollSign;
			}
			
			// Get our version string from the application descriptor
			var appXml:XML = NativeApplication.nativeApplication.applicationDescriptor;
			var ns:Namespace = appXml.namespace();
			appVersion = appXml.ns::filename[0] + ' (' + appXml.ns::versionLabel[0] + ')';
			
			_aEepromByAddr = [];
			_vEepromIdsToCheck = new <String> [];
			_oEepromById = {};
			
			_moveProps = MoveProps.NewFromParameters ( );
			
			_tmrEepromReadWait = new Timer ( EEPROM_READ_LIMIT, 1 );
			_tmrEepromReadWait.addEventListener ( TimerEvent.TIMER, _EepromReadTimedOut );
			
			_tmrEepromWrite = new Timer ( EEPROM_WRITE_INTERVAL, 0 );
			_tmrEepromWrite.addEventListener ( TimerEvent.TIMER, _EepromsWrite );
			
			// instantiate roverData value object
			_roverData = new RoverData();
			
			// bare bones base class that implements IPilotConnector
			pilotConnector = new PilotConnector ( );
			// make sure pilotConnector is never left null
			_OpModeSet ( OpModes.NA );
			
			_camMgr = CameraManager.instance;
			_motMgr = MotionManager.instance;
			_wpsMgr = WaypointsManager.instance;
			
			// read settings
			_LocalFilesInitialize ( );
			
			
			_StageOrientationApply ( app.stage.orientation );
			app.stage.addEventListener ( StageOrientationEvent.ORIENTATION_CHANGE, _StageOrientationChanged );
			app.addEventListener ( ResizeEvent.RESIZE, _StageResized );
			
			callLater ( _SensorsInit );
		}
		
		public function light ( on:Boolean ) : void
		{
			if ( !_bLightEnabled )
				return;
			
			lightOn = on;
			
			if ( lightExternal )
			{
				if ( on )
				{
					mcuSendCommandId ( McuMessage.HEADLIGHT_ON );
				}
				else
				{
					mcuSendCommandId ( McuMessage.HEADLIGHT_OFF );
				}
			}
			else
			{
				if ( on )
				{
					app.stage.displayState = StageDisplayState.FULL_SCREEN;
				}
				else
				{
					app.stage.displayState = StageDisplayState.NORMAL;
				}
			}
			
			pilotConnector.userVarsQueue ( new <MessageData> [ new MessageData ( 'fl', lightOn ) ] );
		}
		
		public function lightCancel ( ) : void
		{
			light ( false );
		}
		
		public function mcuSendCommandByteArray ( ba:ByteArray ) : Boolean
		{
			if ( !mcuConnector )
				return false; // return
			
			return mcuConnector.sendCommand ( ba );
		}
		
		public function mcuSendCommandId ( value:int ) : Boolean
		{
			if ( !mcuConnector )
				return false; // return
			
			return mcuConnector.sendCommandId ( value );
		}
		
		public function motionRequest ( moveProps:MoveProps ) : void
		{
			if ( _bMoveIgnore )
			{
				debugOut ( 'motionRequest discarded due to emergency flags: ' + _uEmFlags );
				return;
			}
			
			_moveProps = moveProps;
			
			// ##### TESTING #####
			if ( _bDebug )
				debugOut ( 'Mcu motion: ' + _moveProps.messageString );
			// ###################
			
			mcuSendCommandByteArray ( _moveProps.messageBytes );
			
			if ( _bMoving != _moveProps.isMoving )
			{
				// update camera config
				_IsMovingSet ( !_bMoving );
			}
		}
		
		public function opModePrompt ( ) : void
		{
			viewStatePush ( 'mode_prompt' );
		}
		
		public function opModeSelected ( mode:uint ) : void
		{
			var uMode:uint = OpModes.ValidateMode ( mode );
			
			if ( _uOpMode == uMode )
			{
				// not changing, so we're done here
				viewStatePop ( 'mode_prompt' );
				return;
			}
			
			// second parameter is false here,
			// because new state will be revealed
			// by _ViewStateSetHome() call below
			viewStatePop ( 'mode_prompt', false );
			
			// dismiss previous op Mode
			_PilotConnectorDismiss ( );
			
			_OpModeSet ( uMode );
			
			var sHome:String;
			// instantiate
			if ( uMode == OpModes.RC )
			{
				// this device acts as simple remote control via Bluetooth
				if ( Multitouch.supportsTouchEvents )
				{
					Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;
				}
				pilotConnector = new PilotConnectorRC ( );
				sHome = 'home_rc';
			}
			else
			{
				if ( Multitouch.supportsTouchEvents )
				{
					Multitouch.inputMode = MultitouchInputMode.NONE;
				}
				if ( uMode == OpModes.NA )
				{
					pilotConnector = new PilotConnector ( );
					sHome = 'home';
				}
				else if ( uMode == OpModes.PP )
				{
					pilotConnector = new PilotConnectorPP ( );
					sHome = 'home_pp';
				}
				else
				{
					// OpModes.CS
					pilotConnector = new PilotConnectorCS ( );
					sHome = 'home_cs';
				}
				
				_GyroActivate ( );
				_GeoActivate ( );
			}
			
			_ViewStateSetHome ( sHome );
		}
		
		public function phoneConfigDone ( params:Object ) : void
		{
			viewStatePop ( 'phone_config' );
			// Bluetooth vs USB Microbridge vs USB Android as host
			userState.mcuConnectModeId = McuConnectModes.ValidateMode ( params.mcuConnectModeId as uint );
			// capabilities storage location
			userState.capabilitiesStorePhone = params.capabilitiesStorePhone as Boolean;
			// camera
			_camMgr.camera = params.camera as Camera;
			userState.cameraIndex = _camMgr.camera.index;
			// phone battery minimum
			userState.phoneBatteryMin = params.phoneBatteryMin as int;
			
			_McuConnectConfigure ( );
		}
		
		public function phoneConfigOpen ( ) : void
		{
			viewStatePush ( 'phone_config' );
		}
		
		public function sleepRequest ( ) : void
		{
			if ( !_bSleep )
			{
				// ##### TESTING #####
				debugOut ( 'Mcu command: ' + McuMessage.SLEEP );
				// ###################
				_SystemsDeactivate ( );
			}
		}
		
		public function sleepWakeToggle ( ) : void
		{
			if ( _bSleep )
				_SystemsActivate ( );
			else
				_SystemsDeactivate ( );
		}
		
		public function statusClear ( ) : void
		{
			isBusy = false;
			_statusData = null;
			_StatusEventDispatch ( );
		}
		
		public function statusSet ( label:String, busy:Boolean = false, icon:Class = null ) : void
		{
			isBusy = busy;
			_statusData = new StatusData ( label, icon );
			_StatusEventDispatch ( );
		}
		
		public function statusSetResource ( rsrc:String, busy:Boolean = false, icon:Class = null, params:Array = null ) : void
		{
			isBusy = busy;
			_statusData = new StatusData ( resourceManager.getString ( 'default', rsrc, params ), icon );
			_StatusEventDispatch ( );
		}
		
		public function viewStatePop ( name:String = '', updateView:Boolean = true ) : void
		{
			var i:int;
			var iLast:int = _vViewStateStack.length - 1;
			if ( iLast > 0 )
			{
				if ( name.length < 1 )
				{
					// basic back button
					_vViewStateStack.pop ( );
				}
				else
				{
					// remove any occurrence(s) of this name from the stack
					for ( i=iLast; i>0; i-- )
					{
						if ( _vViewStateStack [ i ] == name )
						{
							_vViewStateStack.splice ( i, 1 );
						}
					}
				}
				if ( updateView )
				{
					_AppViewStateSet ( _vViewStateStack [ _vViewStateStack.length - 1 ] );
				}
			}
			else if ( name.length < 1 )
			{
				callLater ( exitQuery );
			}
		}
		
		public function viewStatePush ( name:String ) : void
		{
			var i:int;
			var iLast:int = _vViewStateStack.length - 1;
			var iRank:int = _VIEW_STATE_RANKS [ name ];
			if ( iLast > 0 )
			{
				// remove any old occurrence(s) of this name from the stack
				for ( i=iLast; i>0; i-- )
				{
					if ( _vViewStateStack [ i ] == name )
					{
						_vViewStateStack.splice ( i, 1 );
					}
				}
				// starting from the end, insert this
				// after the first item encountered
				// with rank <= this one
				iLast = _vViewStateStack.length - 1;
				for ( i=iLast; i>=0; i-- )
				{
					if ( ( _VIEW_STATE_RANKS [ _vViewStateStack [ i ] ] as int ) <= iRank )
					{
						_vViewStateStack.splice ( i+1, 0, name );
						break;
					}
				}
			}
			else
			{
				// only option is to add onto the end
				_vViewStateStack.push ( name );
			}
			_AppViewStateSet ( _vViewStateStack [ _vViewStateStack.length - 1 ] );
		}
		
		public function wakeRequest ( ) : void
		{
			if ( _bSleep )
			{
				// ##### TESTING #####
				debugOut ( 'Mcu command: ' + McuMessage.WAKEUP );
				// ###################
				_SystemsActivate ( );
			}
		}
		
		// PRIVATE PROPERTIES
		
		private var _aEepromByAddr:Array;
		private var _bMcuConnected:Boolean = false;
		private var _batteryUtil:BatteryUtil;
		private var _bActMnOn:Boolean = false;
		private var _bBatterySupport:Boolean = false;
		private var _bDebug:Boolean = true;
		private var _bDebugVis:Boolean = true;
		private var _bDevDefPortrait:Boolean = true;
		private var _bDevFaceBack:Boolean = false;
		private var _bEepromReadFail:Boolean = false;
		private var _bEepromsNeeded:Boolean = false;
		private var _bExiting:Boolean = false;
		private var _bGeoSupport:Boolean = false;
		private var _bGyroSupport:Boolean = false;
		private var _bLightEnabled:Boolean = false;
		private var _bMoveIgnore:Boolean = false;
		private var _bMoving:Boolean;
		private var _bPanEnabled:Boolean = false;
		private var _bPanMovesDevice:Boolean = true;
		private var _bPanOrTiltEnabled:Boolean = false;
		private var _bPanOrTiltMovesDevice:Boolean = true;
		private var _bVisionOrientCompensate:Boolean = false;
		private var _bSleep:Boolean = false;
		private var _bTiltEnabled:Boolean = false;
		private var _bTiltMovesDevice:Boolean = true;
		private var _camMgr:CameraManager;
		private var _currentCoords:CurrentCoordinates;
		private var _custCmdMgr:CustomCommandManager;
		private var _declinationUtil:DeclinationUtil;
		private var _dirSets:File;
		private var _dirSetsBkp:File;
		private var _fGpsRoomVarUpdate:Function = _NoOp;
		private var _fMcuGpsUpdate:Function = _NoOp;
		private var _fMcuHdgUpdate:Function = _NoOp;
		private var _geo:Geolocation;
		private var _gps:Gps;
		private var _iPanHome:int = 0;
		private var _iPanNet:int = 0;
		private var _iPanReset:int = 0;
		private var _iTiltHome:int = 0;
		private var _iTiltNet:int = 0;
		private var _iTiltReset:int = 0;
		private var _iUltraSonicThreshold:int = 40;
		private var _iVideoActualHt:int;
		private var _iVideoActualWd:int;
		private var _iVidPodHt:int;
		private var _iVidPodWd:int;
		private var _motMgr:MotionManager;
		private var _moveProps:MoveProps; // stores most recent request
		private var _nBatteryPct:Number = 0;
		private var _nDcScale:Number = 112/255;
		private var _nFloatDifNeg:Number = -0.1;
		private var _nFloatDifPos:Number = 0.1;
		private var _nGpsDifNeg:Number = -0.000001;
		private var _nGpsDifPos:Number = 0.000001; // 0.000001 = about 4 inches at the equator
		private var _nHeading:Number = 0;
		private var _nHeadingRaw:Number = 0;
		private var _nNavGpsMsec:Number = NAV_GPS_MSEC_DEFAULT;
		private var _nNavGpsNextTime:Number = 0;
		private var _nNavHdgMsec:Number = NAV_HDG_MSEC_DEFAULT;
		private var _nNavHdgNextTime:Number = 0;
		private var _nPhoneCompassOffset:Number = 270;
		private var _nPhoneOrientationOffset:Number = 0;
		private var _nPhoneOrientationSign:Number = 1;
		private var _nPitch:Number = 0;
		private var _nPitchRaw:Number = 0;
		private var _nPitchSign:Number = 1;
		private var _nRoll:Number = 0;
		private var _nRollRaw:Number = 0;
		private var _nRollSign:Number = -1;
		private var _nVidInsetFract:Number = 0.4; // adjust as GUI requires
		private var _nVidPodAspect:Number;
		private var _oEepromById:Object;
		private var _roverData:RoverData;
		private var _sOrientStage:String = ''; // current orientation
		private var _statusData:StatusData;
		private var _tmrBattery:Timer; // battery check watchdog
		private var _tmrEepromReadWait:Timer // EEPROM read time limit
		private var _tmrEepromWrite:Timer; // EEPROM batch write interval timer
		private var _uEmFlags:uint = 0;
		private var _uHeading:uint = 360; // range is 0-359, so first value acquired won't be assume to be unchanged
		private var _uOpMode:uint;
		private var _uVidSenderRot:uint = 0;
		private var _video:Video;
		private var _vEeproms:Vector.<McuEeprom>;
		private var _vEepromIdsToCheck:Vector.<String>;
		private var _vViewStateStack:Vector.<String> = new <String> ['home'];
		private var _wpsMgr:WaypointsManager;
		
		
		// PRIVATE METHODS
		
		private function _BatchVarsReport ( ) : void
		{
			_fGpsRoomVarUpdate = _GpsRoomVarUpdate; // from now on this method will be called when geolocation changes
			var mdGps:MessageData = new MessageData ( 'gps', _gps, true );
			var vmdRoomVars:Vector.<MessageData> = new <MessageData> [
				mdGps,
				new MessageData ( 'asd', userState.assetsDir ),
				new MessageData ( 'pip', userState.pilotNames )
			];
			pilotConnector.roomVarsQueue ( vmdRoomVars );
			
			var vmdUserVars:Vector.<MessageData> = new <MessageData> [
				new MessageData ( 'appv', appVersion ),
				new MessageData ( 'ccfga', userState.cameraAdjustForMotion ),
				new MessageData ( 'fle', _bLightEnabled ),
				new MessageData ( 'hd', _nHeading ),
				new MessageData ( 'mdc', _declinationUtil.declination ),
				new MessageData ( 'ro', _nRoll ),
				new MessageData ( 'pt', _nPitch ),
				new MessageData ( 'pbte', _bBatterySupport ),
				new MessageData ( 'pbt', _nBatteryPct ),
				mdGps,
				new MessageData ( 'remex', osAllowsExit ),
				new MessageData ( 'sleep', _bSleep ),
				new MessageData ( 'cus', _custCmdMgr, true )
			];
			
			var i_eep:McuEeprom;
			var i_sId:String;
			for ( i_sId in _oEepromById )
			{
				i_eep = _oEepromById [ i_sId ] as McuEeprom;
				if ( i_eep.reportable )
				{
					vmdUserVars.push ( new MessageData ( i_sId, i_eep.value ) );
				}
			}
			
			if ( _wpsMgr.enabled )
			{
				vmdUserVars.push ( _wpsMgr.getActiveMessage ( ), _wpsMgr.getListMessage ( ) );
			}
			
			if ( _bPanEnabled )
				vmdUserVars.push ( new MessageData ( 'cp', _iPanHome + _iPanNet ) );
			
			if ( _bTiltEnabled )
				vmdUserVars.push ( new MessageData ( 'ct', _iTiltHome + _iTiltNet ) );
			
			pilotConnector.userVarsQueue ( vmdUserVars );
		}
		
		private function _BatteryCheckIOS ( event:TimerEvent = null ) : void
		{
			_batteryUtil.check ( );
		}
		
		private function _BatteryUpdated ( event:BatteryEvent ) : void
		{
			_nBatteryPct = 100 * event.batteryLevel;
			if ( FlagsUtil.IsSet ( _uEmFlags, EmergencyFlags.BATTERY ) )
			{
				if ( _nBatteryPct > userState.phoneBatteryMin )
				{
					emergencyFlagsClear ( EmergencyFlags.BATTERY );
				}
			}
			else
			{
				if ( _nBatteryPct < userState.phoneBatteryMin )
				{
					emergencyFlagsSet ( EmergencyFlags.BATTERY );
					callLater ( _SystemsDeactivate );
				}
			}
			if ( !_bSleep )
				pilotConnector.userVarsQueue ( new <MessageData> [ new MessageData ( 'pbt', _nBatteryPct ) ] );
		}
		
		private function _BluetoothConfigEvent ( event:UtilityEvent ) : void
		{
			// for now only using this event type for requesting opening of bluetooth config,
			// so no need to check params
			bluetoothConfigOpen ( );
		}
		
		private function _BluetoothConnected ( event:UtilityEvent ) : void
		{
			var sAddr:String = event.params as String;
			if ( sAddr != userState.bluetoothAddress )
			{
				userState.bluetoothAddress = sAddr;
			}
		}
		
		private function _CustomConfigValidate ( ) : void
		{
			if ( _custCmdMgr.validate ( ) )
			{
				// configuration okay
				statusSetResource ( 'status_custom_valid' );
				pilotConnector.userVarsQueue ( new <MessageData> [ new MessageData ( 'cus', _custCmdMgr, true ) ] );
			}
			else
			{
				// return to configuration
				customConfigOpen ( );
			}
		}
		
		private function _CustomInit ( ) : void
		{
			// first request for instance will
			// initialize singleton and restore
			// custom command config data from dat file, if exists
			_custCmdMgr = CustomCommandManager.instance;
			
			callLater ( _McuConnectConfigure );
		}
		
		private function _DeclinationUpdated ( event:UtilityEvent ) : void
		{
			var nDec:Number = event.params.declination;
			
			var vmdToSend:Vector.<MessageData> = new <MessageData> [ new MessageData ( 'mdc', nDec ) ];
			_GyroHeadingUpdate ( vmdToSend );
			pilotConnector.userVarsQueue ( vmdToSend );
			// _OrientationAdjustUpdate ( );
		}
		
		// returns value between -180 and 180
		private function _DegreesRangeValidate ( value:Number ) : Number
		{
			var nVal:Number = value;
			if ( nVal > 180 )
			{
				do
					nVal -= 360;
				while ( nVal > 180 );
			}
			else if ( nVal < -180 )
			{
				do
					nVal += 360;
				while ( nVal < -180 );
			}
			return nVal;
		}
		
		private function _DeviceFacingInit ( ) : void
		{
			if ( _bDevFaceBack )
			{
				_bLightEnabled = lightExternal;
				_nPhoneCompassOffset = 90;
				_nPitchSign = -_nPitchSign;
				_nRollSign = -_nRollSign;
			}
			else
			{
				_bLightEnabled = true;
			}
		}
		
		private function _EepromCheckVersion ( ) : void
		{
			// get current capabilities schema version
			var i_eep:McuEeprom = _oEepromById [ 'eepv' ] as McuEeprom;
			if ( userState.capabilitiesStorePhone )
			{
				// values stored on phone
				var oStore:Object = _EepromsPhoneRestore ( );
				var bNew:Boolean = true;
				var i_sId:String;
				var i_val:*;
				var i:int;
				var iLim:int;
				if ( oStore != null )
				{
					if  ( oStore.hasOwnProperty ( 'eepv' ) )
					{
						i_val = oStore [ 'eepv' ];
						if ( i_val == i_eep.value )
						{
							bNew = false;
							// EEPROM schema is current, so remove it from list
							// and continue to restore the rest
							_vEepromIdsToCheck.splice ( _vEepromIdsToCheck.indexOf ( 'eepv' ), 1 );
							iLim = _vEepromIdsToCheck.length;
							for ( i=0; i<iLim; i++ )
							{
								i_sId = _vEepromIdsToCheck.pop ( );
								if ( oStore.hasOwnProperty ( i_sId ) )
								{
									i_eep = _oEepromById [ i_sId ] as McuEeprom;
									i_eep.restoreValue ( oStore [ i_sId ] );
								}
							}
						}
					}
				}
				_EepromConfigCaptionsSet ( bNew );
				callLater ( _EepromConfigWrite );
			}
			else
			{
				// stored on Mcu
				if ( _bMcuConnected )
				{
					// try to read them now
					if ( mcuSendCommandByteArray ( i_eep.messageBytesForRead ) )
					{
						_EepromReadTimerReset ( );
						statusSetResource ( 'status_eeprom_read' );
					}
					else
					{
						_EepromReadTimedOut ( );
					}
				}
				else
				{
					// wait until get a connected event
					_bEepromsNeeded = true;
				}
			}
		}
		
		private function _EepromConfigCaptionsSet ( isNew:Boolean ) : void
		{
			// Display appropriate captions, depending upon whether or not we already have
			// stored capabilities configuration data compatible with the current schema.
			// If this is a new installation or an update with new schema version,
			// user will need to configure from scratch.  Otherwise their previous choices
			// will still be in force.
			if ( isNew )
			{
				eepromConfigCaptRsrc = 'eeprom_config_new_title';
				eepromWriteCaptRsrc = 'status_eeprom_write_new';
			}
			else
			{
				eepromConfigCaptRsrc = 'eeprom_config_title';
				eepromWriteCaptRsrc = 'status_eeprom_write';
			}
		}
		
		private function _EepromConfigWrite ( ) : void
		{
			_EepromsProcess ( );
			
			if ( _bEepromReadFail )
			{
				// no point in attempting to write if could not read
				_EepromsWriteDone ( );
				return;
			}
			
			// add to the queue any eeprom items that have changed values and are not already in the list
			var i_sId:String;
			var i_eep:McuEeprom;
			for ( i_sId in _oEepromById )
			{
				i_eep = _oEepromById [ i_sId ] as McuEeprom;
				if ( i_eep.changed && _vEepromIdsToCheck.indexOf ( i_sId ) < 0 )
				{
					_vEepromIdsToCheck.push ( i_sId );
				}
			}
			if ( _vEepromIdsToCheck.length < 1 )
			{
				_EepromsWriteDone ( );
			}
			else
			{
				// have something to write
				if ( userState.capabilitiesStorePhone )
				{
					callLater ( _EepromsPhonePersist );
				}
				else
				{
					callLater ( _EepromsWriteBegin ); 
				}
			}
		}
		
		private function _EepromReadTimedOut ( event:TimerEvent = null ) : void
		{
			_bEepromReadFail = true;
			var sStat:String = resourceManager.getString ( 'default', 'error_eeprom_read' );
			statusSet ( sStat );
			debugOut ( sStat );
			// use defaults for now, but set captions for later
			_EepromConfigCaptionsSet ( true );
			_EepromConfigWrite ( );
		}
		
		private function _EepromReadTimerReset ( ) : void
		{
			_tmrEepromReadWait.reset ( );
			_tmrEepromReadWait.start ( );
		}
		
		private function _EepromReadTimerStop ( ) : void
		{
			_tmrEepromReadWait.stop ( );
		}
		
		private function _EepromsPhonePersist ( ) : void
		{
			var oStore:Object = {};
			for ( var i_sId:String in _oEepromById )
			{
				oStore [ i_sId ] = ( _oEepromById [ i_sId ] as McuEeprom ).value;
			}
			
			try
			{
				var ba:ByteArray = new ByteArray ( );
				ba.writeObject ( oStore );
				
				var f:File = _dirSets.resolvePath ( 'Caps.dat' );
				if ( f.exists ) f.deleteFile ( );
				
				var fs:FileStream = new FileStream();
				// open
				fs.open ( f, FileMode.WRITE );
				// write
				fs.writeBytes ( ba );
				// close
				fs.close();
				
				if ( osAllowsExit )
				{
					var fBkp:File = _dirSetsBkp.resolvePath ( 'Caps.dat' );
					f.copyTo ( fBkp, true );
				}
			}
			catch ( err:Error )
			{
				debugOut ( err.message );
			}
			_EepromsWriteDone ( );
		}
		
		private function _EepromsPhoneRestore ( ) : Object
		{
			var oStore:Object;
			
			var f:File = _dirSets.resolvePath ( 'Caps.dat' );
			if ( !f.exists )
				return oStore; // not yet saved locally
			
			var fs:FileStream = new FileStream();
			// open
			fs.open ( f, FileMode.READ );
			// read
			var ba:ByteArray = new ByteArray();
			fs.readBytes ( ba );
			// close
			fs.close();
			
			try
			{
				oStore = ba.readObject ( );
			}
			catch ( err:Error )
			{
				debugOut ( err.message );
			}
			
			return oStore;
		}
		
		private function _EepromsProcess ( ) : void
		{
			// start with defaults
			_bPanEnabled = false;
			_bTiltEnabled = false;
			_bPanOrTiltEnabled = false;
			_bPanMovesDevice = true;
			_bTiltMovesDevice = true;
			_bPanOrTiltMovesDevice = true;
			_bVisionOrientCompensate = false;
			_iPanHome = 0;
			_iPanNet = 0;
			_iPanReset = 0;
			_iTiltHome = 0;
			_iTiltNet = 0;
			_iTiltReset = 0;
			_wpsMgr.enabled = false;
			_nNavGpsMsec = NAV_GPS_MSEC_DEFAULT;
			_nNavHdgMsec = NAV_HDG_MSEC_DEFAULT;
			_fMcuGpsUpdate = _NoOp;
			_fMcuHdgUpdate = _NoOp;
			var uMode:uint = CoordinatesMessage.COORDS_MODE_DOUBLE;
			try
			{
				_bDevFaceBack = ( _oEepromById.dfb as McuEeprom ).value;
				
				_bPanEnabled = ( _oEepromById.ccp as McuEeprom ).value;
				if ( _bPanEnabled )
				{
					_bPanOrTiltEnabled = true;
					_iPanHome = ( _oEepromById.ccph as McuEeprom ).value;
					_iPanReset = ( _oEepromById.ccpr as McuEeprom ).value;
				}
				
				_bTiltEnabled = ( _oEepromById.cct as McuEeprom ).value;
				if ( _bTiltEnabled )
				{
					_bPanOrTiltEnabled = true;
					_iTiltHome = ( _oEepromById.ccth as McuEeprom ).value;
					_iTiltReset = ( _oEepromById.cctr as McuEeprom ).value;
				}
				
				_bPanMovesDevice = ( _oEepromById.ccpd as McuEeprom ).value;
				
				_bTiltMovesDevice = ( _oEepromById.cctd as McuEeprom ).value;
				
				_bPanOrTiltMovesDevice = ( _bPanMovesDevice || _bTiltMovesDevice );
				
				_bVisionOrientCompensate = (
					( _bPanEnabled && _bPanMovesDevice ) ||
					( _bTiltEnabled && _bTiltMovesDevice )
				);
				
				_wpsMgr.enabled = ( _oEepromById.wpe as McuEeprom ).value;
				if ( _wpsMgr.enabled )
				{
					
					if ( ( _oEepromById.wpf as McuEeprom ).value )
					{
						// float
						if ( ( _oEepromById.wpf32 as McuEeprom ).value )
						{
							// 32-bit
							uMode = CoordinatesMessage.COORDS_MODE_FLOAT;
						}
						else
						{
							// 64-bit
							uMode = CoordinatesMessage.COORDS_MODE_DOUBLE;
						}
					}
					else
					{
						// integer --> see reference:
						// http://sloblog.io/~pdc/kbGgQRBcYsk/latitude-and-longitude-in-32-bits
						uMode = CoordinatesMessage.COORDS_MODE_INTEGER;
					}
					CoordinatesMessage.SetCoordsDataMode ( uMode );
					_currentCoords = CurrentCoordinates.NewFromParameters ( );
					_nNavGpsMsec = ( _oEepromById.wpgi as McuEeprom ).value;
					_nNavHdgMsec = ( _oEepromById.wphi as McuEeprom ).value;
					_fMcuGpsUpdate = _McuGpsUpdate;
					_fMcuHdgUpdate = _McuHeadingUpdate;
				}
				lightExternal = ( _oEepromById.hle as McuEeprom ).value;
				_DeviceFacingInit ( );
			}
			catch ( err:Error )
			{
				var sStat:String = resourceManager.getString ( 'default', 'error_eeprom_item_nf', [ err.message ] );
				debugOut ( sStat );
				statusSet ( sStat );
			}
		}
		
		private function _EepromsRead ( ) : void
		{
			if ( _vEepromIdsToCheck.length < 1 )
			{
				_EepromReadTimerStop ( );
				_EepromConfigCaptionsSet ( false );
				_EepromConfigWrite ( );
				return;
			}
			
			var eep:McuEeprom = _oEepromById [ _vEepromIdsToCheck [ 0 ] ] as McuEeprom;
			if ( mcuSendCommandByteArray ( eep.messageBytesForRead ) )
			{
				_EepromReadTimerReset ( );
			}
			else
			{
				_EepromReadTimedOut ( );
			}
		}
		
		private function _EepromsWrite ( event:TimerEvent = null ) : void
		{
			if ( _vEepromIdsToCheck.length < 1 )
			{
				_EepromsWriteDone ( );
				return;
			}
			
			var eep:McuEeprom = _oEepromById [ _vEepromIdsToCheck.pop ( ) ] as McuEeprom;
			var uCount:uint = eep.byteCount;
			var nMsecs:Number = EEPROM_WRITE_INTERVAL * uCount;
			_tmrEepromWrite.delay = nMsecs;
			// ##### TESTING #####
			debugOut ( 'allowing ' + nMsecs + ' msecs to write ' + uCount + ' bytes to EEPROM at ' + eep.addressHex );
			// ###################
			mcuSendCommandByteArray ( eep.messageBytesForWrite );
		}
		
		private function _EepromsWriteBegin ( ) : void
		{
			statusSetResource ( eepromWriteCaptRsrc );
			_tmrEepromWrite.start ( );
		}
		
		private function _EepromsWriteDone ( ) : void
		{
			statusClear ( );
			_tmrEepromWrite.stop ( );
			if ( _uOpMode == OpModes.NA )
				callLater ( opModePrompt );
		}
		
		private function _EmergencyStateUpdate ( ) : void
		{
			// update user variable
			pilotConnector.userVarsQueue ( new <MessageData> [ new MessageData ( 'ems', _uEmFlags ) ] );
			// If all clear, resume normal activity.
			// Mcu will prevent forward motion if ultrasonic range is too small.
			_MoveIgnoreSet ( _uEmFlags != 0 && _uEmFlags != EmergencyFlags.OBSTACLE );
		}
		
		private function _ExitQueryResponse ( commit:Boolean, data:DialogData ) : void
		{
			if ( data.responseIndex == 0 )
			{
				exitConfirmed ( );
			}
		}
		
		private function _ExitStepExit ( ) : void
		{
			// this does not work on iOS
			NativeApplication.nativeApplication.exit ( );
		}
		
		private function _ExpertModeSet ( value:Boolean ) : void
		{
			expertModeOn = value;
			if ( expertModeOn )
			{
				actionMenuBtnStyleName = 'actionMenuExpert';
				actionMenuBgColor = 0x663214; // 0xcc6600
			}
			else
			{
				actionMenuBtnStyleName = 'actionMenu';
				actionMenuBgColor = 0x294a66; // 0x0066cc
				debugVisible = false;
			}
			userState.expertOn = expertModeOn;
		}
		
		private function _GeoActivate ( ) : void
		{
			if ( !_bGeoSupport )
				return;
			
			// NOTE: Flex is not able to detect if the location is coming from
			// the wifi, network, or the GPS. We would need an ANE to
			// detect if it is specifically the GPS that is turned on.
			
			try
			{
				_geo = new Geolocation();
				// register to receive location updates
				_geo.addEventListener ( GeolocationEvent.UPDATE, _GeolocationUpdated );
				_geo.setRequestedUpdateInterval ( 1000 );
			}
			catch ( err:Error )
			{
				_bGeoSupport = false;
				debugOut ( 'error_geo_init', true, [ err.message ] );;
			}
			
			if ( !_bGeoSupport )
			{
				_declinationUtil.pause ( );
				return;
			}
			// if get here, geo is okay
			
			// Magnetic Declination
			_declinationUtil.addEventListener ( UtilityEvent.DECLINATION, _DeclinationUpdated );
			_declinationUtil.resume ( );
		}
		
		private function _GeoDeactivate ( ) : void
		{
			if ( !_bGeoSupport )
				return;
			
			if ( _geo )
			{
				_geo.removeEventListener ( GeolocationEvent.UPDATE, _GeolocationUpdated );
				_geo = null;
			}
			
			_declinationUtil.pause ( );
			_declinationUtil.removeEventListener ( UtilityEvent.DECLINATION, _DeclinationUpdated );
		}
		
		private function _GeolocationUpdated ( event:GeolocationEvent ) : void
		{
			var bChange:Boolean = false;
			var nDif:Number = event.latitude - _gps.lat;
			if ( nDif < _nGpsDifNeg || nDif > _nGpsDifPos )
			{
				bChange = true;
				_gps.lat = event.latitude
			}
			nDif = event.longitude - _gps.lng;
			if ( nDif < _nGpsDifNeg || nDif > _nGpsDifPos )
			{
				bChange = true;
				_gps.lng = event.longitude;
			}
			_gps.accuracy = event.horizontalAccuracy;
			/*
			if ( event.horizontalAccuracy != _gps.accuracy )
			{
			bChange = true;
			_gps.accuracy = event.horizontalAccuracy;
			}
			if ( event.speed != _gps.speed )
			{
			bChange = true;
			_gps.speed = event.speed;
			}
			*/
			if ( bChange )
			{
				_declinationUtil.setCoordinates ( event.latitude, event.longitude );
				_fMcuGpsUpdate ( event.latitude, event.longitude );
				var vmdGps:Vector.<MessageData> = new <MessageData> [ new MessageData ( 'gps', _gps, true ) ];
				pilotConnector.userVarsQueue ( vmdGps );
				_fGpsRoomVarUpdate ( vmdGps );
			}
		}
		
		private function _GpsRoomVarUpdate ( vmdGps:Vector.<MessageData> ) : void
		{
			pilotConnector.roomVarsQueue ( vmdGps );
		}
		
		private function _GyroActivate ( ) : void
		{
			if ( !_bGyroSupport )
				return;
			
			var gyro:GyroUtil = GyroUtil.instance;
			gyro.service.addEventListener ( GyroscopeEvent.UPDATE, _GyroUpdatedAdvanced );
			gyro.register ( );
		}
		
		private function _GyroDeactivate ( ) : void
		{
			if ( !_bGyroSupport )
				return;
			
			var gyro:GyroUtil = GyroUtil.instance;
			gyro.unregister();
			gyro.service.removeEventListener ( GyroscopeEvent.UPDATE, _GyroUpdatedAdvanced );
		}
		
		// called when there is a significant change in gyro vector, camera turret vector or magnetic declination
		private function _GyroHeadingUpdate ( vmdToSend:Vector.<MessageData> ) : void
		{
			var nVal:Number = _DegreesRangeValidate ( _nHeadingRaw + _declinationUtil.declination + _nPhoneCompassOffset + _nPhoneOrientationOffset - _iPanNet );
			
			var nDif:Number = nVal - _nHeading;
			if ( nDif < _nFloatDifNeg || nDif > _nFloatDifPos )
			{
				_nHeading = nVal;
				
				if ( nVal >= 360 )
				{
					do
					{
						nVal -= 360;
					}
					while ( nVal >= 360 )
				}
				else if ( nVal < 0 )
				{
					do
					{
						nVal += 360;
					}
					while ( nVal < 0 )
				}
				vmdToSend.push ( new MessageData ( 'hd', nVal ) );
				_fMcuHdgUpdate ( nVal );
			}
		}
		
		// called when there is a significant change in either gyro vector or turret vector
		private function _GyroPitchUpdate ( vmdToSend:Vector.<MessageData> ) : void
		{
			var nVal:Number = _DegreesRangeValidate ( _DegreesRangeValidate ( _nPitchRaw + _nPhoneOrientationOffset - _iTiltNet ) );
			
			var nDif:Number = nVal - _nPitch;
			if ( nDif < _nFloatDifNeg || nDif > _nFloatDifPos )
			{
				_nPitch = nVal;
				vmdToSend.push ( new MessageData ( 'pt', nVal ) );
			}
		}
		
		private function _GyroRollUpdate ( vmdToSend:Vector.<MessageData> ) : void
		{
			var nVal:Number = _nRollRaw;
			
			var nDif:Number = nVal - _nRoll;
			if ( nDif < _nFloatDifNeg || nDif > _nFloatDifPos )
			{
				_nRoll = nVal;
				vmdToSend.push ( new MessageData ( 'ro', nVal ) );
			}
		}
		
		private function _GyroUpdatedAdvanced ( event:GyroscopeEvent ) : void
		{
			var vmdToSend:Vector.<MessageData> = new <MessageData> [];
			var nDif:Number;
			var nVal:Number;
			
			// Android phone values assume portrait position, with
			// y axis positive toward top, x axis positive toward right,
			// and z axis positive out of the screen toward user.
			// In landscape position, Android pitch becomes our roll
			// and roll becomes our pitch.
			
			// ##### TODO #####
			// Add logic to allow for the use of devices whose coordinate system
			// defaults to landscape mode, as a few Android tablets are reputed to do.
			// See
			//   http://www.sensorplatforms.com/understanding-orientation-conventions-mobile-platforms/
			// and
			//   http://android-developers.blogspot.com/2010/09/one-screen-turn-deserves-another.html
			// ################
			
			// pitch
			nVal = _DegreesRangeValidate ( _nPhoneOrientationSign * _nPitchSign * ( MathConsts.RADIANS_TO_DEGREES * event.roll + 90 ) );
			
			nDif = nVal - _nPitchRaw;
			if ( nDif < _nFloatDifNeg || nDif > _nFloatDifPos )
			{
				_nPitchRaw = nVal;
				_GyroPitchUpdate ( vmdToSend );
			}
			
			// roll
			nVal = _nPhoneOrientationSign * _nRollSign * MathConsts.RADIANS_TO_DEGREES * event.pitch;
			
			nDif = nVal - _nRollRaw;
			if ( nDif < _nFloatDifNeg || nDif > _nFloatDifPos )
			{
				_nRollRaw = nVal;
				_GyroRollUpdate ( vmdToSend );
			}
			
			// heading
			nVal = event.yaw * MathConsts.RADIANS_TO_DEGREES;
			
			nDif = nVal - _nHeadingRaw;
			if ( nDif < _nFloatDifNeg || nDif > _nFloatDifPos )
			{
				_nHeadingRaw = nVal;
				_GyroHeadingUpdate ( vmdToSend );
			}
			
			// if we have anything, send it
			if ( vmdToSend.length > 0 )
			{
				pilotConnector.userVarsQueue ( vmdToSend );
			}
			
			/*
			if ( _bDeviceDefaultPortrait )
			{
			_qDeviceSensors.fromEulerAngles ( event.pitch, event.roll, event.yaw );
			}
			else
			{
			_qDeviceSensors.fromEulerAngles ( event.roll, event.pitch, event.yaw );
			}
			_OrientationUpdate ( );
			*/
			
			/*
			debugOut (
			'p: ' + Math.round ( event.pitch * RADIANS_TO_DEGREES ) +
			'  r: ' + Math.round ( event.roll * RADIANS_TO_DEGREES ) +
			'  y: ' + Math.round ( event.yaw * RADIANS_TO_DEGREES )
			);
			*/
		}
		
		private function _KeyDown ( event:KeyboardEvent ) : void
		{
			if ( event.keyCode == Keyboard.BACK )
			{
				event.preventDefault ( );
				event.stopImmediatePropagation ( );
				// debugOut ( 'KeyDown BACK' );
			}
			else if ( event.keyCode == Keyboard.MENU )
			{
				// debugOut ( 'KeyDown MENU' );
			}
		}
		
		private function _KeyUp ( event:KeyboardEvent ) : void
		{
			
			if ( event.keyCode == Keyboard.BACK )
			{
				event.preventDefault ( );
				event.stopImmediatePropagation ( );
				callLater ( viewStatePop );
				// debugOut ( 'KeyUp BACK' );
			}
			else if ( event.keyCode == Keyboard.MENU )
			{
				callLater ( actionMenuToggle );
				// debugOut ( 'KeyUp MENU' );
			}
		}
		
		private function _LocalEepromConfigLoad ( ) : void
		{
			var f:File = File.applicationDirectory.resolvePath ( 'config/eeprom.json' );
			var sStat:String;
			if ( !f.exists )
			{
				sStat = resourceManager.getString ( 'default', 'error_eeprom_cfg' );
				debugOut ( sStat );
				statusSet ( sStat );
				return;
			}
			
			try
			{
				var fs:FileStream = new FileStream();
				// open
				fs.open ( f, FileMode.READ );
				
				// read
				var sJson:String = fs.readUTFBytes ( fs.bytesAvailable );
				
				// close
				fs.close ( );
				
				// debugOut ( sJson );
				
				var oJson:Object = JSON.parse ( sJson );
				
				// var sTest:String = '';
				var i_ae:McuEeprom;
				var i_oVal:Object;
				var i_sGrpId:String;
				var i_sId:String;
				var i_uAddr:uint;
				var aEeps:Array = [];
				// accumulate group IDs so can add group header items to config display
				var vGrpIds:Vector.<String> = new <String> [];
				for ( i_sId in oJson )
				{
					i_oVal = oJson [ i_sId ];
					i_ae = McuEeprom.NewFromJson ( i_sId, i_oVal );
					i_uAddr = i_ae.address;
					i_sGrpId = i_ae.groupId;
					_aEepromByAddr [ i_uAddr ] = i_ae;
					if ( vGrpIds.indexOf ( i_sGrpId ) < 0 )
					{
						// first encounter with this group ID
						vGrpIds.push ( i_sGrpId );
						aEeps.push ( new McuEeprom ( 0, 0, i_sGrpId, 'group', null, false, i_sGrpId ) )
					}
					aEeps.push ( i_ae );
					_vEepromIdsToCheck.push ( i_sId );
					_oEepromById [ i_sId ] = i_ae;
					// sTest += i_sId + '  addr: ' + i_ae.address + ',  bytes: ' + i_ae.byteCount + ',  value: ' + i_ae.value + ',  desc: ' + resourceManager.getString('default',i_ae.resource) + '\n';
				}
				aEeps.sortOn ( [ 'groupId', 'address' ], [ Array.CASEINSENSITIVE, Array.NUMERIC ] );
				_vEeproms = Vector.<McuEeprom> ( aEeps );
				// debugOut ( sTest, false, null, false, '' );
				callLater ( _EepromCheckVersion );
			}
			catch ( err:Error )
			{
				sStat = resourceManager.getString ( 'default', 'error_eeprom_cfg_load', [ err.message ] );
				debugOut ( sStat );
				statusSet ( sStat );
			}
		}
		
		private function _LocalFilesInitialize ( ) : void
		{
			// storage directory
			_dirSets = File.applicationStorageDirectory.resolvePath ( 'settings' );
			_dirSets.createDirectory ( ); // no effect if already exists
			if ( osAllowsExit )
			{
				_dirSetsBkp = File.userDirectory.resolvePath ( 'ArxRobotBkp/settings' );
				_dirSetsBkp.createDirectory ( ); // no effect if already exists
			}
			
			// get settings from previous session, if exist
			if ( !_UserStateRestore ( ) )
			{
				userState = new UserState ( false );
			}
			userState.addEventListener ( UserState.USER_STATE_CHANGED, _UserStatePersist );
			
			_camMgr.userStateInit ( userState );
			_motMgr.userStateInit ( userState );
			
			_DeviceFacingInit ( );
			
			_ExpertModeSet ( userState.expertOn );
		}
		
		private function _McuConnectConfigure ( ) : void
		{
			// first deal with existing connection, if any,
			// and check current op mode compatibility
			// with new Mcu mode
			if ( mcuConnector )
			{
				if ( mcuConnector.mode == userState.mcuConnectModeId )
				{
					// not changing, so we're done here
					return;
				}
				
				// if we were in RC op mode
				// and will now not be using Bluetooth,
				// get out of RC mode
				if ( _uOpMode == OpModes.RC && userState.mcuConnectModeId != McuConnectModes.BLUETOOTH )
				{
					opModeSelected ( OpModes.NA );
				}
				// dismiss old connector
				_McuConnectorDismiss ( );
			}
			
			if ( userState.mcuConnectModeId == McuConnectModes.BLUETOOTH )
			{
				// Bluetooth
				mcuConnector = McuConnectorBluetooth.instance;
				mcuBluetooth = McuConnectorBluetooth.instance;
				mcuBluetooth.addEventListener ( UtilityEvent.BLUETOOTH_CONFIG, _BluetoothConfigEvent );
				mcuBluetooth.addEventListener ( UtilityEvent.BLUETOOTH_CONNECTED, _BluetoothConnected );
				mcuBluetooth.setAutoConnectionAddress ( userState.bluetoothAddress );
			}
			else
			{
				if ( userState.mcuConnectModeId == McuConnectModes.USB_ADB )
				{
					// USB adb
					// instantiate server socket to communicate with Mcu
					mcuConnector = McuConnectorSocket.instance;
				}
				else
				{
					// USB Android as host
					// instantiate Primavera ANE to communicate with Mcu
					mcuConnector = McuConnectorPrimavera.instance;
				}
			}
			mcuConnector.addEventListener ( TelemetryEvent.PACKET_PAYLOADS, _McuDataReceived );
			mcuConnector.addEventListener ( UtilityEvent.MCU_CONNECTED, _McuConnected );
			mcuConnector.addEventListener ( UtilityEvent.MCU_DISCONNECTED, _McuDisconnected );
			
			// if this is not our first time here
			// and we have already gotten capabilities data,
			// we don't need to read eeproms again
			// ##### TODO #####
			statusSetResource ( 'status_eeprom_read', true );
			callLater ( _LocalEepromConfigLoad );
		}
		
		private function _McuConnectorDismiss ( ) : void
		{
			if ( mcuConnector )
			{
				if ( mcuConnector.isBluetooth )
				{
					mcuBluetooth.removeEventListener ( UtilityEvent.BLUETOOTH_CONFIG, _BluetoothConfigEvent );
					mcuBluetooth.removeEventListener ( UtilityEvent.BLUETOOTH_CONNECTED, _BluetoothConnected );
					mcuBluetooth = null;
				}
				mcuConnector.removeEventListener ( TelemetryEvent.PACKET_PAYLOADS, _McuDataReceived );
				mcuConnector.removeEventListener ( UtilityEvent.MCU_CONNECTED, _McuConnected );
				mcuConnector.removeEventListener ( UtilityEvent.MCU_DISCONNECTED, _McuDisconnected );
				mcuConnector.dismiss ( );
				mcuConnector = null;
			}
		}
		
		private function _McuDataReceived ( event:TelemetryEvent ) : void
		{
			var vbaIn:Vector.<ByteArray> = event.payloads;
			
			// we're getting something, so evidently the Mcu is connected
			_McuConnectedSet ( true );
			
			// NOTE: ByteArray automatically changes its position property to the index immediately after the latest read or write operation.
			//       The bytesAvailable property contains the number of bytes left between the current position and the end.
			var bytes:ByteArray;
			var bytesOut:ByteArray;
			var vmdToSend:Vector.<MessageData> = new <MessageData> [];
			var bTurretChange:Boolean = false;
			var bRangeChange:Boolean = false;
			var bValid:Boolean;
			var ccc:CustomCommandConfig;
			var iDatum:int;
			// var iLoops:int = 0;
			var nDatum:Number;
			var sDbg:String;
			var sId:String;
			var uDatum:uint;
			var uId:uint;
			var uLen:uint;
			var eep:McuEeprom;
			
			while ( vbaIn.length > 0 )
			{
				/*
				if ( ++iLoops > 50 )
				{
				debugOut ( 'Mcu data loop limit exceeded' );
				break;
				}
				*/
				bytes = vbaIn.shift ( );
				bytes.position = 0;
				uId = bytes.readUnsignedByte ( );
				switch ( uId )
				{
					case McuConnector.MOTOR1_CURRENT_ID:
						// motor 1 current
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.MOTOR1_CURRENT_ID, 1 ) ] );
						}
						else
						{
							uDatum = bytes.readUnsignedShort ( ) * 34;
							if ( uDatum != _roverData.motor1Current )
							{
								// aData.push ( new SFSUserVariable ( 'TBD', uDatum ) );
								_roverData.motor1Current = uDatum;
							}
						}
						break;
					case McuConnector.MOTOR2_CURRENT_ID:
						// motor 2 current
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.MOTOR2_CURRENT_ID, 1 ) ] );
						}
						else
						{
							uDatum = bytes.readUnsignedShort ( ) * 34;
							if ( uDatum != _roverData.motor2Current )
							{
								// aData.push ( new SFSUserVariable ( 'TBD', uDatum ) );
								_roverData.motor2Current = uDatum;
							}
						}
						break;
					case McuConnector.TEMP_SENSOR_ID:
						// temperature
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.TEMP_SENSOR_ID, 1 ) ] );
						}
						else
						{
							iDatum = bytes.readShort ( );
							if ( iDatum != _roverData.temperature )
							{
								vmdToSend.push ( new MessageData ( 'btm', iDatum ) );
								_roverData.temperature = iDatum;
							}
						}
						break;
					case McuConnector.RANGE_LEFT_ID:
						// ultrasonic ranger left
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.RANGE_LEFT_ID, 1 ) ] );
						}
						else
						{
							iDatum = bytes.readShort ( );
							if ( iDatum != _roverData.usRangeLeft )
							{
								vmdToSend.push ( new MessageData ( 'usl', iDatum ) );
								_roverData.usRangeLeft = iDatum;
								bRangeChange = true;
							}
						}
						break;
					case McuConnector.RANGE_RIGHT_ID:
						// ultrasonic ranger right
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.RANGE_RIGHT_ID, 1 ) ] );
						}
						else
						{
							iDatum = bytes.readShort ( );
							if ( iDatum != _roverData.usRangeRight )
							{
								vmdToSend.push ( new MessageData ( 'usr', iDatum ) );
								_roverData.usRangeRight = iDatum;
								bRangeChange = true;
							}
						}
						break;
					case McuConnector.CLEAN_BATTERY_ID:
						// electronics battery
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.CLEAN_BATTERY_ID, 1 ) ] );
						}
						else
						{
							iDatum = bytes.readShort ( );
							if ( iDatum != _roverData.cleanBat )
							{
								vmdToSend.push ( new MessageData ( 'cbt', iDatum ) );
								_roverData.cleanBat = iDatum;
							}
						}
						break;
					case McuConnector.DIRTY_BATTERY_ID:
						// motor battery
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.DIRTY_BATTERY_ID, 1 ) ] );
						}
						else
						{
							iDatum = bytes.readShort ( );
							if ( iDatum != _roverData.dirtyBat )
							{
								vmdToSend.push ( new MessageData ( 'dbt', iDatum ) );
								_roverData.dirtyBat = iDatum;	
							}
						}
						break;
					case McuConnector.PAN_POSITION_ID:
						// pan
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.PAN_POSITION_ID, 1 ) ] );
						}
						else
						{
							uDatum = bytes.readUnsignedShort ( );
							if ( uDatum != _roverData.panAngle )
							{
								vmdToSend.push ( new MessageData ( 'cp', uDatum ) );
								_roverData.panAngle = uDatum;
								// ##### TESTING #####
								// debugOut ( 'pan degrees from Mcu: ' + uDatum );
								// ###################
								if ( _bPanEnabled )
								{
									if ( _VisionPanUpdate ( uDatum ) )
									{
										bTurretChange = true;
									}
								}
							}
						}
						break;
					case McuConnector.TILT_POSITION_ID:
						// tilt
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.TILT_POSITION_ID, 1 ) ] );
						}
						else
						{
							uDatum = bytes.readUnsignedShort ( );
							if ( uDatum != _roverData.tiltAngle )
							{
								vmdToSend.push ( new MessageData ( 'ct', uDatum ) );
								_roverData.tiltAngle = uDatum;
								// ##### TESTING #####
								// debugOut ( 'tilt degrees from Mcu: ' + uDatum );
								// ###################
								if ( _bTiltEnabled )
								{
									if ( _VisionTiltUpdate ( uDatum ) )
									{
										bTurretChange = true;
									}
								}
							}
						}
						break;
					case McuConnector.EEPROM_RESPONSE_ID:
						// EEPROM read result
						bValid = false;
						sId = '';
						eep = _aEepromByAddr [ bytes.readUnsignedShort ( ) ] as McuEeprom;
						if ( eep != null )
						{
							if ( bytes.bytesAvailable > 0 )
							{
								uLen = bytes.readUnsignedByte ( );
								sId = eep.id;
								if ( sId == 'eepv' )
								{
									// checking EEPROM schema version
									if ( bytes.bytesAvailable >= uLen )
									{
										bValid = true;
										uDatum = bytes.readUnsignedShort ( );
										if ( ( eep.value as uint ) == uDatum )
										{
											// EEPROM schema is current, so remove from list
											// and continue to read the rest
											_vEepromIdsToCheck.splice ( _vEepromIdsToCheck.indexOf ( sId ), 1 );
											callLater ( _EepromsRead );
										}
										else
										{
											// need to initialize EEPROM
											debugOut ( 'status_eeprom_update', true, null, true );
											_EepromConfigCaptionsSet ( true );
										}
									}
								}
								else
								{
									// reading all other EEPROMs
									if ( eep.restoreValueFromByteArray ( bytes ) )
									{
										bValid = true;
										_vEepromIdsToCheck.splice ( _vEepromIdsToCheck.indexOf ( sId ), 1 );
										callLater ( _EepromsRead );
									}
								}
							}
						}
						if ( !bValid )
						{
							debugOut ( 'error_mcu_eeprom_response', true, [ sId ] );
						}
						break;
					case McuConnector.EMERGENCY_ID:
						sDbg = resourceManager.getString ( 'default', 'mcu_emergency', [ HexStringUtil.HexStringFromByteArray ( bytes ) ] );
						debugOut ( sDbg );
						statusSet ( sDbg );
						// ##### TODO
						// report to control panel?
						break;
					case McuConnector.COMMAND_DUMP_ID:
						bytesOut = new ByteArray ( );
						bytes.readBytes ( bytesOut );
						debugOut ( 'mcu_cmd_dump', true, [ HexStringUtil.HexStringFromByteArray ( bytesOut ) ] );
						break;
					case McuConnector.EXCEPTION_ID:
						if ( bytes.bytesAvailable < 2 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.EXCEPTION_ID, 1 ) ] );
						}
						else
						{
							debugOut ( 'error_mcu_cmd_pkt_' + bytes [ 1 ], true, [ HexStringUtil.HexNumberStringFromUintBytes ( bytes [ 2 ], 1 ) ] );
						}
						break;
					case McuConnector.ROUTE_STATUS_ID:
						if ( bytes.bytesAvailable < 1 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.ROUTE_STATUS_ID, 1 ) ] );
						}
						else
						{
							uDatum = bytes.readUnsignedByte ( );
							vmdToSend.push ( new MessageData ( 'wpr', uDatum ) );
						}
						break;
					case McuConnector.WAYPOINT_ARRIVE_ID:
						if ( bytes.bytesAvailable < 1 )
						{
							debugOut ( 'error_mcu_args', true, [ HexStringUtil.HexNumberStringFromUintBytes ( McuConnector.WAYPOINT_ARRIVE_ID, 1 ) ] );
						}
						else
						{
							uDatum = bytes.readUnsignedByte ( );
							_wpsMgr.waypointArrived ( uDatum );
						}
						break;
					default:
						if ( _custCmdMgr.idIsInCustomRange ( uId ) )
						{
							// custom command status
							if ( _custCmdMgr.suspend )
							{
								// command interpretation unavailable due to configuration ongoing
								debugOut ( 'error_mcu_custom_suspend', true, [ uId ] );
							}
							else
							{
								ccc = _custCmdMgr.getCommandConfigById ( uId );
								if ( ccc != null )
								{
									// valid ID
									if ( ccc.setCommandValueFromByteArray ( bytes ) )
									{
										// had enough bytes to update value, so update user variable
										vmdToSend.push ( new MessageData ( 'cu' + uId, ccc, true ) );
									}
									else
									{
										// too few bytes available
										debugOut ( 'error_mcu_custom_bytes', true, [ uId ] );
									}
								}
								else
								{
									// command not configured
									debugOut ( 'error_mcu_custom_cfg', true, [ uId ] );
								}
							}
						}
						else
						{
							// unknown telemetry ID
							debugOut ( 'error_mcu_id', true, [ uId ] );
						}
						break;
				} // end switch
				
				bytes.clear ( );
				
			} // end while loop
			
			if ( vmdToSend.length > 0 )
			{
				pilotConnector.userVarsQueue ( vmdToSend );
			}
			
			if ( bTurretChange )
			{
				_VisionMoveUpdateCommit ( );
			}
			
			if ( bRangeChange )
			{
				_UltraSonicRangeCheck ( );
			}
		}
		
		private function _McuConnected ( event:UtilityEvent ) : void
		{
			_McuConnectedSet ( true );
		}
		
		private function _McuDisconnected ( event:UtilityEvent ) : void
		{
			_McuConnectedSet ( false );
		}
		
		private function _McuGpsUpdate ( lat:Number, lng:Number ) : void
		{
			var nTime:Number = new Date().getTime();
			if ( nTime < _nNavGpsNextTime )
				return;
			
			_nNavGpsNextTime = nTime + _nNavGpsMsec;
			_currentCoords.latitude = lat;
			_currentCoords.longitude = lng;
			mcuSendCommandByteArray ( _currentCoords.messageBytesByCoordsMode );
		}
		
		private function _McuHeadingUpdate ( hdg:Number ) : void
		{
			var nTime:Number = new Date().getTime();
			if ( nTime < _nNavHdgNextTime )
				return;
			
			_nNavHdgNextTime = nTime + _nNavHdgMsec;
			
			var uVal:uint = uint ( Math.round ( hdg ) );
			if ( uVal > 359 )
			{
				uVal = 0;
			}
			if ( uVal != _uHeading )
			{
				// value has changed, so update the Mcu
				_uHeading = uVal;
				var ba:ByteArray = new ByteArray ( );
				ba.writeByte ( McuMessage.HEADING );
				ba.writeShort ( _uHeading );
				mcuSendCommandByteArray ( ba );
			}
		}
		
		private function _NoOp ( ... args ) : void { }
		
		private function _PilotConnectorDismiss ( ) : void
		{
			if ( _uOpMode == OpModes.CS || _uOpMode == OpModes.PP )
			{
				// remove listeners and stop sensor polling
				_GeoDeactivate ( );
				_GyroDeactivate ( );
			}
			
			if ( !pilotConnector )
				return;
			
			// dispose
			pilotConnector.dismiss ( );
			pilotConnector = null;
		}
		
		private function _SensorsInit ( ) : void
		{
			// Battery
			_batteryUtil = BatteryUtil.instance;
			if ( _batteryUtil.isSupported )
			{
				_bBatterySupport = true;
				_batteryUtil.service.addEventListener ( BatteryEvent.BATTERY_INFO, _BatteryUpdated );
				if ( os == OS_IOS )
				{
					_tmrBattery = new Timer ( BATTERY_CHECK_MSECS, 0 );
					_tmrBattery.addEventListener ( TimerEvent.TIMER, _BatteryCheckIOS );
					_tmrBattery.start ( );
				}
				_batteryUtil.register();
			}
			
			// Gyroscope supported?
			var gyro:GyroUtil = GyroUtil.instance;
			if ( gyro.isSupported )
			{
				if ( gyro.isAdvancedDataSupported )
				{
					_bGyroSupport = true;
					debugOut ( 'status_gyro_support', true );
				}
				else
				{
					debugOut ( 'error_gyro_advanced_support', true );
				}
			}
			else
			{
				debugOut ( 'error_gyro_support', true );
			}
			
			// Geolocation supported?
			_gps = new Gps ( );
			_bGeoSupport = Geolocation.isSupported;
			if ( _bGeoSupport )
			{
				debugOut ( 'status_geo_support', true );
			}
			else
			{
				debugOut ( 'error_geo_support', true );
			}
			
			_declinationUtil = DeclinationUtil.instance;
			
			callLater ( _CustomInit );
		}
		
		private function _StageOrientationApply ( orientation:String = null ) : void
		{
			// configure compensation for GUI vs Device orientation
			
			// ##### TODO #####
			// With the addition of portrait orientations, our
			// interpretation of device orientation in 3D space
			// for the Control Panel positional displays, already
			// fragile and a hodge-podge of fudge factors, is now
			// thoroughly broken and needs a complete rework more than ever.
			// ################
			if ( orientation != null )
			{
				_sOrientStage = orientation;
			}
			debugOut ( 'orient: ' + _sOrientStage + ', wd: ' + app.width + ', ht: ' + app.height ); // TESTING
			orientedPortrait = ( app.height > app.width );
			_iVidPodWd = app.width;
			_iVidPodHt = app.height;
			if ( orientedPortrait )
			{
				_uVidSenderRot = 270;
			}
			else
			{
				_uVidSenderRot = 0;
			}
			_nVidPodAspect = 1.0 * _iVidPodHt / _iVidPodWd;
			
			switch ( _sOrientStage )
			{
				case StageOrientation.ROTATED_LEFT:
					_nPhoneOrientationOffset = 270;
					_nPhoneOrientationSign = -1;
					_bDevDefPortrait = !orientedPortrait;
					break;
				case StageOrientation.ROTATED_RIGHT:
					_nPhoneOrientationOffset = 90;
					_nPhoneOrientationSign = 1;
					_bDevDefPortrait = !orientedPortrait;
					break;
				case StageOrientation.UPSIDE_DOWN:
					_nPhoneOrientationOffset = 180;
					_nPhoneOrientationSign = -1;
					_bDevDefPortrait = orientedPortrait;
					break;
				default:
					// StageOrientation.DEFAULT or StageOrientation.UNKNOWN
					_nPhoneOrientationOffset = 0;
					_nPhoneOrientationSign = 1;
					_bDevDefPortrait = orientedPortrait;
					var vOrs:Vector.<String> = app.stage.supportedOrientations;
					if ( vOrs.length < 2 || _sOrientStage == StageOrientation.UNKNOWN )
					{
						// we have a problem
						debugOut ( 'error_orientations', true, [ vOrs.join ( ', ' ) ] );
					}
					break;
			}
			
			dispatchEvent ( new Event ( APP_RESIZED ) );
		}
		
		private function _StageOrientationChanged ( event:StageOrientationEvent ) : void
		{
			_sOrientStage = event.afterOrientation;
		}
		
		private function _StageOrientationLock ( ) : void
		{
			var sOrient:String = app.stage.orientation;
			app.stage.autoOrients = false;
			app.stage.setOrientation ( sOrient );
			_StageOrientationApply ( sOrient );
			statusSetResource ( 'status_rot_lock_1' );
		}
		
		public function stageOrientationLockToggle ( ) : void
		{
			if ( app.stage.autoOrients )
			{
				_StageOrientationLock ( );
			}
			else
			{
				_StageOrientationUnlock ( );
			}
			_RotationLockChangedDispatch ( );
		}
		
		private function _StageOrientationUnlock ( ) : void
		{
			app.stage.autoOrients = true;
			statusSetResource ( 'status_rot_lock_0' );
		}
		
		private function _StageResized ( event:ResizeEvent ) : void
		{
			debugOut ( '_StageResized' ); // TESTING
			_StageOrientationApply ( );
		}
		
		private function _StatusEventDispatch ( ) : void
		{
			dispatchEvent ( new StatusDataEvent ( StatusDataEvent.STATUS_DATA_MESSAGE, _statusData ) );
		}
		
		private function _SystemsActivate ( ) : void
		{
			// tasks necessary to resume full activity, such as
			// acquire wake lock, start streaming video/audio,
			// start or increase frequency of sensor polling,
			// resume magnetic declination checks
			_IsSleepingSet ( false );
			NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;
			
			pilotConnector.wake ( );
			
			if ( _uOpMode == OpModes.CS || _uOpMode == OpModes.PP )
			{
				_GeoActivate ( );
				_GyroActivate ( );
			}
			
			mcuSendCommandId ( McuMessage.WAKEUP );
			
			pilotConnector.userVarsQueue ( new <MessageData> [ new MessageData ( 'sleep', _bSleep ) ] );
		}
		
		private function _SystemsDeactivate ( ) : void
		{
			// tasks necessary to go dormant and converve power, such as
			// release wake lock, stop streaming video/audio,
			// stop or decrease frequency of sensor polling,
			// pause magnetic declination checks
			pilotConnector.sleep ( );
			
			if ( _uOpMode == OpModes.CS || _uOpMode == OpModes.PP )
			{
				_GeoDeactivate ( );
				_GyroDeactivate ( );
			}
			
			mcuSendCommandId ( McuMessage.SLEEP );
			
			NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.NORMAL;
			
			if ( !_bExiting )
			{
				_IsSleepingSet ( true );
				pilotConnector.userVarsQueue ( new <MessageData> [ new MessageData ( 'sleep', _bSleep ) ] );
			}
		}
		
		private function _UltraSonicRangeCheck ( ) : void
		{
			if ( FlagsUtil.IsSet ( _uEmFlags, EmergencyFlags.OBSTACLE ) )
			{
				// can it be cleared?
				if ( _roverData.usRangeLeft >= _iUltraSonicThreshold && _roverData.usRangeRight >= _iUltraSonicThreshold )
				{
					emergencyFlagsClear ( EmergencyFlags.OBSTACLE, true );
				}
			}
			else
			{
				// should it be set?
				if ( _roverData.usRangeLeft < _iUltraSonicThreshold || _roverData.usRangeRight < _iUltraSonicThreshold )
				{
					emergencyFlagsSet ( EmergencyFlags.OBSTACLE, true );
				}
			}
		}
		
		private function _UserStatePersist ( event:Event = null ) : void
		{
			try
			{
				var ba:ByteArray = new ByteArray ( );
				ba.writeObject ( userState );
				
				var f:File = _dirSets.resolvePath ( 'UserState.dat' );
				if ( f.exists ) f.deleteFile ( );
				
				var fs:FileStream = new FileStream();
				// open
				fs.open ( f, FileMode.WRITE );
				// write
				fs.writeBytes ( ba );
				// close
				fs.close();
				if ( osAllowsExit )
				{
					var fBkp:File = _dirSetsBkp.resolvePath ( 'UserState.dat' );
					f.copyTo ( fBkp, true );
				}
			}
			catch ( err:* )
			{
				debugOut ( err );
			}
		}
		
		private function _UserStateRestore ( ) : Boolean
		{
			registerClassAlias ( 'UserState', UserState as Class );
			registerClassAlias ( 'CameraConfig', CameraConfig as Class );
			
			var f:File = _dirSets.resolvePath ( 'UserState.dat' );
			if ( !f.exists )
			{
				// not yet saved locally or else app update wiped out app storage
				if ( osAllowsExit )
				{
					// might have a backup
					var fBkp:File = _dirSetsBkp.resolvePath ( 'UserState.dat' );
					if ( fBkp.exists )
					{
						// have backup
						try
						{
							_dirSetsBkp.copyTo ( _dirSets, true );
							
						}
						catch ( err:Error )
						{
							debugOut ( 'error_userstate_restore', true, [ err.message ] );
							return false;
						}
					}
					else
					{
						return false;  // no backup
					}
				}
				else
				{
					return false; // with iOS not possible
				}
				
			}
			
			try
			{
				var fs:FileStream = new FileStream();
				// open
				fs.open ( f, FileMode.READ );
				// read
				var ba:ByteArray = new ByteArray();
				fs.readBytes ( ba );
				// close
				fs.close();
				
				userState = ba.readObject ( );
			}
			catch ( err:Error )
			{
				debugOut ( 'error_userstate_restore', true, [ err.message ] );
				return false;
			}
			
			return true;
		}
		
		private function _ViewStateSetHome ( name:String ) : void
		{
			_vViewStateStack [ 0 ] = name;
			_AppViewStateSet ( _vViewStateStack [ _vViewStateStack.length - 1 ] );
		}
		
		private function _VisionMoveUpdateCommit ( ) : void
		{
			// convert this to use quaternions
			// and compensate orientation interpretation only when
			// pan and tilt are accomplished by moving the device
			
			// _bVisionOrientCompensate _bPanMovesDevice _bTiltMovesDevice _bPanOrTiltMovesDevice
			
			// ##### TODO #####
			
			var vmdToSend:Vector.<MessageData> = new <MessageData> [];
			_GyroPitchUpdate ( vmdToSend );
			_GyroRollUpdate ( vmdToSend );
			_GyroHeadingUpdate ( vmdToSend );
			if ( vmdToSend.length > 0 )
			{
				pilotConnector.userVarsQueue ( vmdToSend );
			}
			// _OrientationAdjustUpdate ( );
		}
		
		private function _VisionPanUpdate ( val:int ) : Boolean
		{
			var bChange:Boolean = false;
			if ( _bPanEnabled )
			{
				var iNet:int = val - _iPanHome;
				if ( iNet != _iPanNet )
				{
					bChange = true;
					_iPanNet = iNet;
				}
			}
			return bChange;
		}
		
		private function _VisionTiltUpdate ( val:int  ) : Boolean
		{
			var bChange:Boolean = false;
			if ( _bTiltEnabled )
			{
				var iNet:int = val - _iTiltHome;
				if ( iNet != _iTiltNet )
				{
					bChange = true;
					_iTiltNet = iNet;
				}
			}
			return bChange;
		}
	}
}
class SingletonEnforcer {}